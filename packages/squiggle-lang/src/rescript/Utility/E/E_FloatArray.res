module FloatArray = Js.TypedArray2.Float64Array

type t = FloatArray.t
let make = FloatArray.make
let fromLength = FloatArray.fromLength
let length = FloatArray.length
let reduce = FloatArray.reduce
let filter = FloatArray.filter
let slice = FloatArray.slice
let sort = (t: t) => t->FloatArray.copy->FloatArray.sortInPlace
let toArray: t => array<float> = %raw(`a => Array.from(a)`)
let map = FloatArray.map

let unsafe_get = (t: t, i: int) => t->FloatArray.unsafe_get(i)
let get = (t: t, i: int) => i >= t->length ? None : Some(t->FloatArray.unsafe_get(i))
let set = (t: t, i: int) => t->FloatArray.unsafe_set(i)

let mean = t => t->toArray->Jstat.mean
let geomean = t => t->toArray->Jstat.geomean
let mode = t => t->toArray->Jstat.mode
let variance = t => t->toArray->Jstat.variance
let stdev = t => t->toArray->Jstat.stdev
let sum = t => t->toArray->Jstat.sum
let product = Jstat.product
let random = Js.Math.random_int
let min = t => t->toArray->Js.Math.minMany_float
let max = t => t->toArray->Js.Math.maxMany_float
let percentile = (t, b) => Jstat.percentile(t->toArray, b, false)

module Sorted = {
  let min = (t: t) => t->length > 0 ? Some(FloatArray.unsafe_get(t, 0)) : None
  let max = (t: t) => t->length > 0 ? Some(FloatArray.unsafe_get(t, t->length - 1)) : None
  let range = (~min=min, ~max=max, a) =>
    switch (min(a), max(a)) {
    | (Some(min), Some(max)) => Some(max -. min)
    | _ => None
    }

  /*
      This function goes through a sorted array and divides it into two different clusters:
      continuous samples and discrete samples. The discrete samples are stored in a mutable map.
      Samples are thought to be discrete if they have at least `minDiscreteWight` duplicates.

      If the min discrete weight is 4, that would mean that at least four elements needed from a specific
      value for that to be kept as discrete. This is important because in some cases, we can expect that
      some common elements will be generated by regular operations. The final continuous array will be sorted.

      This function is performance-critical, don't change it significantly without benchmarking
      SampleSet->PointSet conversion performance.
 */
  let splitContinuousAndDiscreteForMinWeight = (sortedArray: t, ~minDiscreteWeight: int): (
    t,
    E_FloatFloatMap.t,
  ) => {
    // TODO - preallocate as typed array, then trim
    let continuous: array<float> = []
    let discrete = E_FloatFloatMap.empty()

    let addData = (count: int, value: float): unit => {
      if count >= minDiscreteWeight {
        E_FloatFloatMap.add(value, count->Belt.Int.toFloat, discrete)
      } else {
        for _ in 1 to count {
          continuous->Js.Array2.push(value)->ignore
        }
      }
    }

    let (finalCount, finalValue) = reduce(
      sortedArray,
      // initial prev value doesn't matter; if it collides with the first element of the array, flush won't do anything
      (. (count, prev), element) => {
        if element == prev {
          (count + 1, prev)
        } else {
          // new value, process previous ones
          addData(count, prev)
          (1, element)
        }
      },
      (0, 0.),
    )

    // flush final values
    addData(finalCount, finalValue)

    (continuous->make, discrete)
  }
}
