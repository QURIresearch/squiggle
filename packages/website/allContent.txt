# Squiggle Documentation, One Page
This file is auto-generated from the documentation files in the Squiggle repository. It includes our Peggy Grammar. It is meant to be given to an LLM. It is not meant to be read by humans.
--- 


## Peggy Grammar 

 // Documentation: https://peggyjs.org/documentation.html

{{
  import * as h from './peggyHelpers.js';
}}

start
  = _nl start:outerBlock _nl finalComment?  {return start}

zeroOMoreArgumentsBlockOrExpression = lambda / innerBlockOrExpression

outerBlock
  = imports:importStatementsList
    statements:statementsList
    finalExpression:(statementSeparator @expression)?
    {
      if (finalExpression) {
        statements.push(finalExpression);
      }
      return h.nodeProgram(imports, statements, location());
    }
  / imports:importStatementsList
    finalExpression:expression
    { return h.nodeProgram(imports, [finalExpression], location()); }

importStatementsList = (@importStatement __nl)*

importStatement
  = _nl 'import' __ file:string variable:(__ 'as' __ @identifier)
  { return [file, variable]; }

innerBlockOrExpression
  = quotedInnerBlock
  / finalExpression:expression
    { return h.nodeBlock([finalExpression], location()); }

quotedInnerBlock
  = '{' _nl
    statements:statementsList
    finalExpression:(statementSeparator @expression) _nl
    '}'
    {
      if (finalExpression) {
        statements.push(finalExpression);
      }
      return h.nodeBlock(statements, location());
    }
  / '{' _nl
    finalExpression:expression _nl
    '}'
    { return h.nodeBlock([finalExpression], location()); }

statementsList = statement|1.., statementSeparator|

statement
  = letStatement
  / defunStatement
  / voidStatement

voidStatement
  = "call" _nl value:zeroOMoreArgumentsBlockOrExpression
    {
      const variable = h.nodeIdentifier("_", location());
      return h.nodeLetStatement(variable, value, false, location());
    }

letStatement
  = exported:("export" __nl)? variable:variable _ assignmentOp _nl value:zeroOMoreArgumentsBlockOrExpression
    { return h.nodeLetStatement(variable, value, Boolean(exported), location()); }

defunStatement
  = exported:("export" __nl)? variable:variable '(' _nl args:functionParameters _nl ')' _ assignmentOp _nl body:innerBlockOrExpression
    {
      const value = h.nodeLambda(args, body, location(), variable);
      return h.nodeDefunStatement(variable, value, Boolean(exported), location());
    }

  assignmentOp "assignment" = '='

functionParameters = functionParameter|.., commaSeparator|
  functionParameter
    = id:dollarIdentifier annotation:(_ ':' _nl @expression)?
    {
      return annotation ? h.nodeIdentifierWithAnnotation(id.value, annotation, location()) : id;
    }

/*
Rules for expressions start here.

Peggy doesn't have built-in support for operator precedence, so we have to recurse into expressions,
starting from the lowest precedence rules (ternary operators), up to highest precedence rules
(function calls and field lookups), until we bottom down at atoms and start all over again.
*/

expression = ifthenelse / ternary / logicalOr

// Ternaries

ifthenelse
  = 'if' __nl condition:logicalOr
    __nl 'then' __nl trueExpression:innerBlockOrExpression
    __nl 'else' __nl falseExpression:(ifthenelse/innerBlockOrExpression)
    { return h.nodeTernary(condition, trueExpression, falseExpression, 'IfThenElse', location()); }

ternary
  = condition:logicalOr _ '?' _nl trueExpression:logicalOr _ ':' _nl falseExpression:(ternary / logicalOr)
    { return h.nodeTernary(condition, trueExpression, falseExpression, 'C', location()); }

// Binary operators

logicalOr
  = head:logicalAnd tail:(_ @logicalOrOp _nl @logicalAnd)*
  { return h.makeInfixChain(head, tail, location()); }
  logicalOrOp "operator" = '||'

logicalAnd
  = head:equality tail:(_ @logicalAndOp _nl @equality)*
  { return h.makeInfixChain(head, tail, location()); }
  logicalAndOp "operator" = '&&'

equality
  = left:relational _ operator:equalityOp _nl right:relational
  { return h.nodeInfixCall(operator, left, right, location()); }
  / relational

  equalityOp "operator" = '==' / '!='

relational
  = left:credibleInterval _ operator:relationalOp _nl right:credibleInterval
  { return h.nodeInfixCall(operator, left, right, location()); }
  / credibleInterval

  relationalOp "operator" = '<=' / '<' / '>=' / '>'

credibleInterval
  = head:additive tail:(__ @credibleIntervalOp __nl @additive)*
  { return h.makeInfixChain(head, tail, location()); }
  credibleIntervalOp "operator" = 'to'

additive
  = head:multiplicative tail:(_ @additiveOp _nl @multiplicative)*
  { return h.makeInfixChain(head, tail, location()); }
  additiveOp "operator" = '+' / '-' / '.+' / '.-'

multiplicative
  = head:power tail:(_ @multiplicativeOp _nl @power)*
  { return h.makeInfixChain(head, tail, location()); }
  multiplicativeOp "operator" = '*' / '/' / '.*' / './'

power
  = left:chainFunctionCall _ operator:powerOp _nl right:power
  { return h.nodeInfixCall(operator, left, right, location()); }
  / chainFunctionCall
  powerOp "operator" = '^' / '.^'

chainFunctionCall
  = head:unary tail:(_ ('->') _nl @chainedFunction)*
  {
    return tail.reduce(function(result, element) {
      return h.nodePipe(result, element.callable, element.args, location());
    }, head);
  }

  chainedFunction
    = fn:callableBasicValue '(' _nl args:functionArguments _nl ')'
      { return { callable: fn, args }; }
    / fn:callableBasicValue
      { return { callable: fn, args: [] }; }

  callableBasicValue = staticCollectionElement / valueConstructor / variable

// Unary operator

unary
  = unaryOperator:unaryOperator _nl right:(unary/postOperator)
  { return h.nodeUnaryCall(unaryOperator, right, location())}
  / postOperator

  unaryOperator "unary operator" = '-' / '.-' / '!'

// Function calls and field lookups

postOperator
  = collectionElement
  / atom

staticCollectionElement
  = head:atom &('['/'.') // should we allow whitespace before the first []?
    tail:(
      _ '[' _nl arg:expression  _nl ']' {return {mode: 'bracket', arg}}
    / '.' arg:$dollarIdentifier {return {mode: 'dot', arg}} // TODO: should we allow whitespace before "."?
    )*
  {
    return tail.reduce(function(result, element) {
      switch (element.mode) {
        case 'dot':
          return h.nodeDotLookup(result, element.arg, location());
        case 'bracket':
          return h.nodeBracketLookup(result, element.arg, location());
        default:
          throw new Error("Parser implementation error");
      }
    }, head);
  }

collectionElement
  = head:atom &('['/'('/'.')
    tail:(
      _ '(' _nl args:functionArguments _nl ')'
      { return {mode: 'call', args}; }
    / _ '[' _nl arg:expression _nl ']'
      { return {mode: 'bracket', arg}; }
    / '.' arg:$dollarIdentifier
      { return {mode: 'dot', arg}; }
    )*
  {
    return tail.reduce(function(result, element) {
      switch (element.mode) {
        case 'call':
          return h.nodeCall(result, element.args, location());
        case 'dot':
          return h.nodeDotLookup(result, element.arg, location());
        case 'bracket':
          return h.nodeBracketLookup(result, element.arg, location());
        default:
          throw new Error("Parser implementation error");
      }
    }, head);
  }

functionArguments = expression|.., commaSeparator|

atom
  = '(' _nl @expression _nl ')'
  / basicValue

basicValue = valueConstructor / basicLiteral

// Basic literals such as numbers, strings and booleans

basicLiteral
  = string
  / number
  / boolean
  / variable
  / voidLiteral

voidLiteral 'void'
  = "()" {return h.nodeVoid(location());}

variable = dollarIdentifierWithModule / dollarIdentifier

dollarIdentifierWithModule 'identifier'
  = head:$moduleIdentifier
    tail:('.' _nl @$moduleIdentifier)* '.' _nl
    final:$dollarIdentifier
  {
    const modifiers = [head, ...tail, final];
    const modifiedIdentifier = modifiers.join('.');
    return h.nodeIdentifier(modifiedIdentifier, location());
  }
  moduleIdentifier 'identifier' = ([A-Z]+[_a-z0-9]i*)

identifier 'identifier'
  = ([_a-z]+[_a-z0-9]i*) { return h.nodeIdentifier(text(), location()); }

unitIdentifier 'identifier'
  = 'minutes' / 'hours' / 'days' / 'years' / 'n' / 'm' / 'k' / 'M' / 'B' / 'G' / 'T' / 'P' / '%'

dollarIdentifier 'identifier'
  = ([\$_a-z]+[\$_a-z0-9]i*) { return h.nodeIdentifier(text(), location()); }

escapeSeq 'escape sequence' 
  = "\\"
     @( esc:[^u]          { return h.parseEscapeSequence([esc], location(), error) }
      / esc:("u" . . . .) { return h.parseEscapeSequence(esc, location(), error) }
      )

string 'string' 
  = "'" characters:(!("'" / "\\") @. / escapeSeq)* "'" { return h.nodeString(characters.join(""), location()); }
  / '"' characters:(!('"' / "\\") @. / escapeSeq)* '"' { return h.nodeString(characters.join(""), location()); }

number = number:float unit:unitIdentifier?
  {
    if (unit === null) {
      return number;
    }
    else {
      return h.nodeUnitValue(number, unit, location());
    }
  }

float 'number' = significand:floatSignificand exponent:floatExponent?
  {
    return h.nodeFloat({
      integer: significand.integer,
      fractional: significand.fractional,
      exponent,
    }, location());
  }
  
  floatSignificand =
    integer:intLiteral "." fractional:($d+)? {
      return {
        integer,
        fractional,
      };
    }
    / integer:intLiteral {
      return {
        integer,
        fractional: null,
      };
    }
    / "." fractional:$(d+) {
      return {
        integer: 0,
        fractional,
      };
    }

  floatExponent = [e]i @value:signedIntLiteral
  intLiteral = d+ { return parseInt(text(), 10); }
  signedIntLiteral = ('-'/'+')? d+ { return parseInt(text(), 10); }
  d = [0-9]

boolean 'boolean'
  = ('true' / 'false') ! [a-z]i ! [_$]
  { return h.nodeBoolean(text() === 'true', location()); }

// Contructors - delimited blocks such as {} and []

valueConstructor
  = arrayConstructor
  / lambda
  / quotedInnerBlock
  / dictConstructor

lambda
  = '{' _nl '|' _nl args:functionParameters _nl '|' _nl statements:statementsList  finalExpression: (statementSeparator @expression)  _nl '}'
  {
    statements.push(finalExpression);
    return h.nodeLambda(args, h.nodeBlock(statements, location()), location(), undefined);
  }
  / '{' _nl '|' _nl args:functionParameters _nl '|' _nl finalExpression: expression  _nl '}'
  { return h.nodeLambda(args, finalExpression, location(), undefined); }

arrayConstructor 'array'
  = '[' _nl ']'
    { return h.nodeArray([], location()); }
  / '[' _nl args:array_elements _nl ']'
    { return h.nodeArray(args, location()); }

  array_elements = @expression|1.., commaSeparator| commaSeparator?

dictConstructor 'dict'
  = '{' _nl '}'
    { return h.nodeDict([], location()); }
  / '{' _nl args:array_dictEntries _nl '}'
    { return h.nodeDict(args, location()); }

  array_dictEntries = @(
    keyValuePair
    / identifier // shorthand
  )| 1.., commaSeparator|commaSeparator?

  keyValuePair
    = key:expression _ ':' _nl value:expression
    { return h.nodeKeyValue(key, value, location()); }

// Separators

_ 'whitespace'
  = whiteSpaceCharactersOrComment*

_nl 'whitespace'
  = (whiteSpaceCharactersOrComment / commentOrNewLine)*

__ 'whitespace'
  = whiteSpaceCharactersOrComment+

__nl 'whitespace'
  = (whiteSpaceCharactersOrComment / commentOrNewLine)+

statementSeparator ';'
  = _ (';' / commentOrNewLine)+ _nl

commaSeparator ',' = _ ',' _nl

commentOrNewLine = finalComment? newLine
  newLine "newline" = [\n\r]

finalComment "line comment"
  = _ ('//') comment:($([^\r\n]*)) { options.comments.push(h.lineComment(comment, location())); }

whiteSpaceCharactersOrComment = whiteSpaceCharacters / delimitedComment

  delimitedComment  "comment"
    = '/*' comment:($(
      ([^*] / [*][^/])*
    )) '*/' { options.comments.push(h.blockComment(comment, location())); }
  // delimitedComment  "comment"
  //   = '/*' comment:($([^*])*) '*/' { options.comments.push(h.blockComment(comment, location())); }

  whiteSpaceCharacters = [ \t]

 

 --- 

 ---
description: Squiggle is still very early. The main first goal is to become stable (to reach version 1.
---

# Roadmap 

Squiggle is still young. The main first goal is to become stable (to reach version 1.0). Right now we think it is useable to use for small projects, but do note that there are very likely some math bugs and performance problems.

If you have preferences or suggestions for our roadmap, please say so! Post your thoughts in the Github discussion or in the Discord.

## Programming Language Features

- A simple type system
- Optional and default paramaters for functions
- Some testing
- Much better code editor integration
- DateTime support

## Distribution Features

There are many important distribution types that Squiggle doesn't yet support. Some key functions we'd like include:

[Metalog Distribution](https://en.wikipedia.org/wiki/Metalog_distribution)  
Add the Metalog distribution, and some convenient methods for generating these distributions. This might be a bit tricky because we might need or build a library to fit data. There's no Metalog javascript library yet, this would be pretty useful. There's already a Metalog library in Python, so that one could be used for inspiration.

`Distribution.smoothen(p)`  
Takes a distribution and smoothens it. For example, [Elicit Forecast](https://forecast.elicit.org/) does something like this, with uniform distributions.

## Major Future Additions
**An interface to interpret & score Squiggle files**  
Squiggle functions need to be aggregated and scored. This should be done outside one Squiggle file. Maybe this should also be done in Squiggle, or maybe it should be done using Javascript.

My guess is that there should eventually be some way for people to declare that some of their Squiggle values are meant to be formally declared, to be scored and similar by others. Then other programs can read these files, and either use the values, or score them.

Of course, we'd also need good math for how the scoring should work, exactly.

This interface should also be able to handle changing Squiggle values. This is because people would be likely to want to update their functions over time, and that should be taken into account for scoring.

**Importance & quality scores**  
Workflows/functionality to declare the importance and coveredness of each part of the paramater space. For example, some subsets of the paramater space of a function might be much more important to get right than others. Similarly, the analyst might be much more certain about some parts than others. Ideally. they could decline sections.

**Static / sensitivity analysis**  
Guesstimate has Sensitivity analysis that's pretty useful. This could be quite feasible to add, though it will likely require some thinking.

**Annotation**  
It might be useful to allow people to annotate functions and variables with longer descriptions, maybe Markdown. This could very much help interpretation/analysis of these items.

**Randomness seeds**  
Right now, Monte Carlo simulations are totally random. It would be nicer to be able to enter a seed somehow in order to control the randomness. Or, with the same seed, the function should always return the same values. This would make debugging and similar easier.

**Caching/memoization**  
There are many performance improvements that Squiggle could have. We'll get to some of them eventually.



---
description: "Language features: an overview of syntax, operators, functions, and more"
---

import { SquiggleEditor } from "@quri/squiggle-components";

# Language Features 

## Program Structure

A Squiggle program consists of a series of definitions (for example, `x = 5`, `f(x) = x * x`). This can optionally conclude with an *end expression*.

If an end expression is provided, it becomes the evaluated output of the program, and only this result will be displayed in the viewer. Otherwise, all top-level variable definitions will be displayed.

<SquiggleEditor
  defaultCode={`x = 5
y = 10
x + y`}
/>

<SquiggleEditor
  defaultCode={`x = 5
y = 10`}
/>

## Immutability

All variables in Squiggle are immutable, similar to other functional programming languages like OCaml or Haskell.

In the case of container types (lists and dictionaries), this implies that an operation such as myList[3] = 10 is not permitted. Instead, we recommend using `List.map`, `List.reduce` or other [List functions](/docs/Api/List).

In case of basic types such as numbers or strings, the impact of immutability is more subtle.

Consider this code:

```squiggle
x = 5
x = x + 5
```

While it appears that the value of x has changed, what actually occurred is the creation of a new variable with the same name, which [shadowed](https://en.wikipedia.org/wiki/Variable_shadowing) the previous x variable.

In most cases, shadowing behaves identically to what you'd expect in languages like JavaScript or Python.

One case where shadowing matters is closures:

<SquiggleEditor
  defaultCode={`x = 5
argPlusX(y) = x + y

x = x + 5

argPlusX(5)`}
/>

In the above example, the `argPlusX` function captures the value of `x` from line 1, not the newly shadowed `x` from line 4. As a result, `argPlusX(5)` returns 10, not 15.

## Blocks

Blocks are special expressions in Squiggle that can contain any number of local definitions and end with an expression.

<SquiggleEditor
defaultCode={`x = { 5 } // same as "x = 5"
y = {
  t = 10 // local variable, won't be available outside of the block body
  5 * t // end expression
}
`} />

## Conditionals

If/then/else statements in Squiggle are values too.

<SquiggleEditor
  defaultCode={`x = 5
if x<8 then 10 else 3`}
/>

See [Control flow](/docs/Guides/ControlFlow) for more details and examples.

## Comments

<SquiggleEditor
  defaultCode={`// This is a single-line comment\n
/*
This is a multiple
-line comment.
*/
foo = 5

/**
This is a docstring.
Because it starts with "/**", it will be displayed in the viewer if it precedes a public variable definition.
*/
bar = 6
`}
/>

## Pipes

Squiggle features [data-first](https://www.javierchavarri.com/data-first-and-data-last-a-comparison/) pipes. Functions in the standard library are organized to make this convenient.

<SquiggleEditor
  defaultCode={`normal(5,2) -> truncateLeft(3) -> SampleSet.fromDist -> SampleSet.map({|r| r + 10})`}
/>

## Standard Library

Squiggle features a simple [standard libary](/docs/Api/Dist).

Most functions are namespaced under their respective types to keep functionality distinct. Certain popular functions are usable without their namespaces.

For example,

<SquiggleEditor
  defaultCode={`a = List.upTo(0, 5000) -> SampleSet.fromList // namespaces required
b = normal(5,2) // namespace not required
c = 5 to 10 // namespace not required`}
/>



---
description: Explore common pitfalls and misunderstandings in Squiggle's handling of distributions
---

import { SquiggleEditor } from "@quri/squiggle-components";

# Gotchas

## Point Set Distributions Conversions

Point Set conversions are done with [kernel density estimation](https://en.wikipedia.org/wiki/Kernel_density_estimation), which is lossy. This might be particularly noticeable in cases where distributions should be entirely above zero.

In this example, we see that the median of this (highly skewed) distribution is positive when it's in a Sample Set format, but negative when it's converted to a Point Set format.

<SquiggleEditor
  defaultCode={`dist = SampleSet.fromDist(5 to 100000000)
{
    sampleSetMedian: quantile(dist, .5),
    pointSetMedian: quantile(PointSet.fromDist(dist), .5),
    dist: dist
}`}
/>

---

This can be particularly confusing for visualizations. Visualizations automatically convert distributions into Point Set formats. Therefore, they might often show negative values, even if the underlying distribution is fully positive.

We plan to later support more configuration of kernel density estimation, and for visualiations of Sample Set distributions to instead use histograms.

## Sample Set Correlations

Correlations with Sample Set distributions are a bit complicated. Monte Carlo generations with Squiggle are ordered. The first sample in one Sample Set distribution will correspond to the first sample in a distribution that comes from a resulting Monte Carlo generation. Therefore, Sample Set distributions in a chain of Monte Carlo generations are likely to all be correlated with each other. This connection breaks if any node changes to the Point Set or Symbolic format.

In this example, we subtract all three types of distributions by themselves. Notice that the Sample Set distribution returns 1. The other two return the result of subtracting one normal distribution from a separate uncorrelated distribution. These results are clearly very different to each other.

<SquiggleEditor
  defaultCode={`sampleSetDist = normal(5, 2)
pointSetDist = sampleSetDist -> PointSet.fromDist
symbolicDist = Sym.normal(5, 2)
[
  sampleSetDist - sampleSetDist,
  pointSetDist - pointSetDist,
  symbolicDist - symbolicDist,
]`}
/>



---
description: "Squiggle Function Overview"
---
import { SquiggleEditor } from "@quri/squiggle-components";

# Functions

## Basic syntax

<SquiggleEditor
  defaultCode={`f(t) = normal(t^2, t^1.2+.01)
f`}
/>

There's no `return` statement in Squiggle; function definitions are values.

If you need to define local variables in functions, you can use blocks:

<SquiggleEditor
  defaultCode={`mul6(x) = {
  t = x * 2
  t * 3
}`}
/>

## Anonymous Functions

`f(x, y) = x * y` and `f = {|x, y| x * y}` are equivalent.

Squiggle functions are values, and you can save them to variables, pass them to other functions as arguments, return functions from functions, and so on.

<SquiggleEditor defaultCode={`{|t| normal(t^2, t^1.2+.01)}`} />

## Function Visualization

The Squiggle viewer can automatically visualize two types of functions, without manual plots:

1. `(number) => number`
2. `(number) => distribution`

<SquiggleEditor defaultCode={`numberToNumber(x) = x * x
numberToDist(x) = normal(x + 1, 3)
otherFunction(x, y) = x + y`} />

When Squiggle displays a single parameter function, it needs to select some range of parameter values.

The default range is 0 to 10.

You can manually set the the range in the following ways:

- With `Plot.numericFn` or `Plot.distFn` plots, using the `xScale` parameter
- Through the chart's settings in the UI (look for a gear icon next to the variable name)
- With parameter annotations (explained below)

## Parameter Annotations

Function parameters can be annotated with _domains_.

Examples:

- `x: Number.rangeDomain({ min: 5, max: 10 })`
- `x: [5, 10]` — shortcut for `Number.rangeDomain(...)`

Annotations help to document possible values that can be passed as a parameter's value.

Annotations will affect the parameter range used in the function's chart. For more control over function charts, you can use the [Plot module API](/docs/Api/Plot).

Domains are checked on function calls; `f(x: [1,2]) = x; f(3)` will fail.

We plan to support other kinds of domains in the future; for now, only numeric ranges are supported.

<SquiggleEditor
  defaultCode={`yearToValue(year: [2020, 2100]) = 1.04 ^ (year - 2020)`}
/>

### Annotation Reflection

<SquiggleEditor
  defaultCode={`f(x: [1, 20]) = x * x
f.parameters[0]`}
/>

Domains and parameter names can be accessed by the `fn.parameters` property.

For example, domains extracted with `.parameters` can be reused in annotations of other parameters:

<SquiggleEditor
  defaultCode={`f(x: [1, 20]) = x * x
g(x: f.parameters[0].domain) = x * x * x
`}
/>


---
description: Various functions for operating on distributions
---

import { SquiggleEditor } from "@quri/squiggle-components";

# Distribution Functions

## Standard Operations

Here are the ways we combine distributions.

### Addition

A horizontal right shift. The addition operation represents the distribution of the sum of
the value of one random sample chosen from the first distribution and the value one random sample
chosen from the second distribution.

<SquiggleEditor
  defaultCode={`dist1 = 1 to 10
dist2 = triangular(1,2,3)
dist1 + dist2`}
/>

### Subtraction

A horizontal left shift. The subtraction operation represents the distribution of the value of
one random sample chosen from the first distribution minus the value of one random sample chosen
from the second distribution.

<SquiggleEditor
  defaultCode={`dist1 = 1 to 10
dist2 = triangular(1,2,3)
dist1 - dist2`}
/>

### Multiplication

A proportional scaling. The multiplication operation represents the distribution of the multiplication of
the value of one random sample chosen from the first distribution times the value one random sample
chosen from the second distribution.

<SquiggleEditor
  defaultCode={`dist1 = 1 to 10
dist2 = triangular(1,2,3)
dist1 * dist2`}
/>

We also provide concatenation of two distributions as a syntax sugar for `*`

<SquiggleEditor defaultCode="(0.1 to 1) * triangular(1,2,3)" />

### Division

A proportional scaling (normally a shrinking if the second distribution has values higher than 1).
The division operation represents the distribution of the division of
the value of one random sample chosen from the first distribution over the value one random sample
chosen from the second distribution. If the second distribution has some values near zero, it
tends to be particularly unstable.

<SquiggleEditor
  defaultCode={`dist1 = 1 to 10
dist2 = triangular(1,2,3)
dist1 / dist2`}
/>

### Exponentiation

A projection over a contracted x-axis. The exponentiation operation represents the distribution of
the exponentiation of the value of one random sample chosen from the first distribution to the power of
the value one random sample chosen from the second distribution.

<SquiggleEditor defaultCode={`(0.1 to 1) ^ beta(2, 3)`} />

### The base `e` exponential

<SquiggleEditor
  defaultCode={`dist = triangular(1,2,3)
exp(dist)`}
/>

### Logarithms

A projection over a stretched x-axis.

<SquiggleEditor
  defaultCode={`dist = triangular(1,2,3)
log(dist)`}
/>

<SquiggleEditor defaultCode={`log10(5 to 10)`} />

Base `x`

<SquiggleEditor defaultCode={`log(5 to 10, 2)`} />

## Pointwise Operations

### Pointwise addition

For every point on the x-axis, operate the corresponding points in the y axis of the pdf.

**Pointwise operations are done with `PointSetDist` internals rather than `SampleSetDist` internals**.

<SquiggleEditor defaultCode={`Sym.lognormal({p5: 1, p95: 3}) .+ Sym.triangular(5,6,7)`} />

### Pointwise multiplication

<SquiggleEditor defaultCode={`Sym.lognormal({p5: 1, p95: 5}) .* Sym.uniform(1,8)`} />

## Standard Functions

### Probability density function

The `pdf(dist, x)` function returns the density of a distribution at the
given point x.

<SquiggleEditor defaultCode="pdf(normal(0,1),0)" />

#### Validity

- `x` must be a scalar
- `dist` must be a distribution

### Cumulative density function

The `cdf(dist, x)` gives the cumulative probability of the distribution
or all values lower than x. It is the inverse of `quantile`.

<SquiggleEditor defaultCode="cdf(normal(0,1),0)" />

#### Validity

- `x` must be a scalar
- `dist` must be a distribution

### Quantile

The `quantile(dist, prob)` gives the value x for which the sum of the probability for all values
lower than x is equal to prob. It is the inverse of `cdf`. In the literature, it
is also known as the quantiles function. In the optional `summary statistics` panel which appears
beneath distributions, the numbers beneath 5%, 10%, 25% etc are the quantiles of that distribution
for those precentage values.

<SquiggleEditor defaultCode="quantile(normal(0,1),0.5)" />

#### Validity

- `prob` must be a scalar (please only put it in `(0,1)`)
- `dist` must be a distribution

### Mean

The `mean(distribution)` function gives the mean (expected value) of a distribution.

<SquiggleEditor defaultCode="mean(normal(5, 10))" />

### Sampling a distribution

The `sample(distribution)` samples a given distribution.

<SquiggleEditor defaultCode="sample(normal(0, 10))" />

## Converting between distribution formats

We can convert any distribution into the `SampleSet` format

<SquiggleEditor defaultCode="SampleSet.fromDist(normal(5, 10))" />

Or the `PointSet` format

<SquiggleEditor defaultCode="PointSet.fromDist(normal(5, 10))" />

#### Validity

- Second argument to `SampleSet.fromDist` must be a number.

## Normalization

Some distribution operations (like horizontal shift) return an unnormalized distriibution.

We provide a `normalize` function

<SquiggleEditor defaultCode="normalize((0.1 to 1) + triangular(0.1, 1, 10))" />

#### Validity - Input to `normalize` must be a dist

We provide a predicate `isNormalized`, for when we have simple control flow

<SquiggleEditor defaultCode="isNormalized((0.1 to 1) * triangular(0.1, 1, 10))" />

#### Validity

- Input to `isNormalized` must be a dist

## `inspect`

You may like to debug by right clicking your browser and using the _inspect_ functionality on the webpage, and viewing the _console_ tab. Then, wrap your squiggle output with `inspect` to log an internal representation.

<SquiggleEditor defaultCode="inspect(SampleSet.fromDist(0.1 to 1))" />

Save for a logging side effect, `inspect` does nothing to input and returns it.

## Truncate

You can cut off from the left

<SquiggleEditor defaultCode="truncateLeft(Sym.normal(5,3), 6)" />

You can cut off from the right

<SquiggleEditor defaultCode="truncateRight(Sym.normal(5,3), 6)" />

You can cut off from both sides

<SquiggleEditor defaultCode="truncate(Sym.normal(5,3), 1, 7)" />



---
description: Various ways to create Squiggle distributions
---

import { Callout, Tabs, Tab } from "nextra/components";

import { SquiggleEditor } from "@quri/squiggle-components";

# Distribution Creation

## Normal

```squiggle
normal(mean: number, standardDeviation: number)
normal({mean: number, standardDeviation: number})
normal({p5: number, p95: number})
normal({p10: number, p90: number})
normal({p25: number, p75: number})
```

Creates a [normal distribution](https://en.wikipedia.org/wiki/Normal_distribution) with the given mean and standard deviation.

<Tabs items={["normal(5,1)", "normal(1B, 1B)"]}>
  <Tab>
    <SquiggleEditor defaultCode="normal(5, 1)" />
  </Tab>
  <Tab>
    <SquiggleEditor defaultCode="normal(1B, 1B)" />
  </Tab>
</Tabs>


[Wikipedia](https://en.wikipedia.org/wiki/Normal_distribution)

## Lognormal

```squiggle
lognormal(mu: number, sigma: number)
lognormal({mean: number, standardDeviation: number})
lognormal({p5: number, p95: number})
lognormal({p10: number, p90: number})
lognormal({p25: number, p75: number})
```

Creates a [lognormal distribution](https://en.wikipedia.org/wiki/Log-normal_distribution) with the given mu and sigma.

`Mu` and `sigma` represent the mean and standard deviation of the normal which results when
you take the log of our lognormal distribution. They can be difficult to directly reason about. However, there are several alternative ways to specify a lognormal distribution which are often easier to reason about.

<SquiggleEditor defaultCode="lognormal(0, 0.7)" />


[Wikipedia](https://en.wikipedia.org/wiki/Log-normal_distribution)

<details>
  <summary>
    ❓ Understanding <bold>mu</bold> and <bold>sigma</bold>
  </summary>  
  The log of <code>lognormal(mu, sigma)</code> is a normal distribution with
  mean <code>mu</code>
  and standard deviation <code>sigma</code>. For example, these two distributions
  are identical:  
  <SquiggleEditor
    defaultCode={`normalMean = 10
normalStdDev = 2
logOfLognormal = log(lognormal(normalMean, normalStdDev))
[logOfLognormal, normal(normalMean, normalStdDev)]`}
  />
</details>

## To

```squiggle
(5thPercentile: number) to (95thPercentile: number)
to(5thPercentile: number, 95thPercentile: number)
```

The `to` function is an easy way to generate lognormal distributions using predicted _5th_ and _95th_ percentiles. It's the same as ``lognormal({p5, p95})``, but easier to write and read.

<Tabs items={["5 to 10", "to(5, 10)", "1 to 10000"]}>
  <Tab>
    <SquiggleEditor defaultCode="5 to 10" />
  </Tab>
  <Tab>
    <code>5 to 10</code> does the same thing as <code>to(5,10)</code>.
    <SquiggleEditor defaultCode="to(5,10)" />
  </Tab>
  <Tab>
    It's very easy to generate distributions with very long tails. These can be
    impossible to see without changing view settings. (These settings are
    available in the Playground, but not this smaller editor component)
    <SquiggleEditor defaultCode="1 to 10000" />
  </Tab>
</Tabs>

### Arguments

- `5thPercentile`: number
- `95thPercentile`: number, greater than `5thPercentile`

<Callout>
  **Tip**  
  "<bold>To</bold>" is a great way to generate probability distributions very
  quickly from your intuitions. It's easy to write and easy to read. It's
  often a good place to begin an estimate.
</Callout>

<Callout type="warning">
  **Caution**  
  If you haven't tried [calibration
  training](https://www.lesswrong.com/posts/LdFbx9oqtKAAwtKF3/list-of-probability-calibration-exercises),
  you're likely to be overconfident. We recommend doing calibration training
  to get a feel for what a 90 percent confident interval feels like.
</Callout>

## Uniform

```squiggle
uniform(low:number, high:number)
```

Creates a [uniform distribution](<https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)>) with the given low and high values.

<SquiggleEditor defaultCode="uniform(3,7)" />

### Arguments

- `low`: Number
- `high`: Number greater than `low`

<Callout type="warning">
  **Caution**  
  While uniform distributions are very simple to understand, we find it rare
  to find uncertainties that actually look like this. Before using a uniform
  distribution, think hard about if you are really 100% confident that the
  paramater will not wind up being just outside the stated boundaries.  
  One good example of a uniform distribution uncertainty would be clear
  physical limitations. You might have complete complete uncertainty on what
  time of day an event will occur, but can say with 100% confidence it will
  happen between the hours of 0:00 and 24:00.
</Callout>

## Point Mass

```squiggle
pointMass(value:number)
```


Creates a discrete distribution with all of its probability mass at point `value`.

Few Squiggle users call the function `pointMass()` directly. Numbers are often (but not always) converted into point mass distributions automatically, when it is appropriate.

For example, in the function `mixture(1,2,normal(5,2))`, the first two arguments will get converted into point mass distributions
with values at 1 and 2. Therefore, this is the same as `mixture(pointMass(1),pointMass(2),pointMass(5,2))`.

`pointMass()` distributions are currently the only discrete distributions accessible in Squiggle.

<Tabs
  items={[
    "pointMass(3)",
    "mixture(1,3,5)",
    "normal(5,2) * 6",
    "dotAdd(normal(5,2), 6)"
  ]}
>
  <Tab>
    <SquiggleEditor defaultCode="pointMass(3)" />
  </Tab>
  <Tab>
    <SquiggleEditor defaultCode="mixture(1,3,5)" />
  </Tab>
  <Tab>
    <SquiggleEditor defaultCode="normal(5,2) * 6" />
  </Tab>
  <Tab>
    <SquiggleEditor defaultCode="dotAdd(normal(5,2), 6)" />
  </Tab>
</Tabs>

### Arguments

- `value`: Number

## Beta

```squiggle
beta(alpha:number, beta:number)
beta({mean: number, stdev: number})
```

Creates a [beta distribution](https://en.wikipedia.org/wiki/Beta_distribution) with the given `alpha` and `beta` values. For a good summary of the beta distribution, see [this explanation](https://stats.stackexchange.com/a/47782) on Stack Overflow.

<Tabs
  items={[
    "beta(10, 20)",
    "beta(1000, 1000)",
    "beta(1, 10)",
    "beta(10, 1)",
    "beta(0.8, 0.8)",
    "beta({mean: 0.39, stdev: 0.1})",
  ]}
>
  <Tab>
    <SquiggleEditor defaultCode="Sym.beta(10,20)" />
  </Tab>
  <Tab>
    <SquiggleEditor defaultCode="Sym.beta(1000, 2000)" />
  </Tab>
  <Tab>
    <SquiggleEditor defaultCode="Sym.beta(1, 10)" />
  </Tab>
  <Tab>
    <SquiggleEditor defaultCode="Sym.beta(10, 1)" />
  </Tab>
  <Tab>
    <SquiggleEditor defaultCode="Sym.beta(0.8, 0.8)" />
  </Tab>
  <Tab>
    <SquiggleEditor defaultCode="Sym.beta({mean: 0.39, stdev: 0.1})" />
  </Tab>
</Tabs>

### Arguments

- `alpha`: Number greater than zero
- `beta`: Number greater than zero

<Callout type="warning">
  **Caution with small numbers**  
  Squiggle struggles to show beta distributions when either alpha or beta are
  below 1.0. This is because the tails at ~0.0 and ~1.0 are very high. Using a
  log scale for the y-axis helps here.

  <details>
    <summary>Examples</summary>
    <Tabs
      items={[
        "beta(0.3, 0.3)",
        "beta(0.5, 0.5)",
        "beta(0.8, 0.8)",
        "beta(0.9, 0.9)",
      ]}
    >
      <Tab>
        <SquiggleEditor defaultCode="Sym.beta(0.3, 0.3)" />
      </Tab>
      <Tab>
        <SquiggleEditor defaultCode="Sym.beta(0.5, 0.5)" />
      </Tab>
      <Tab>
        <SquiggleEditor defaultCode="Sym.beta(.8,.8)" />
      </Tab>
      <Tab>
        <SquiggleEditor defaultCode="Sym.beta(.9,.9)" />
      </Tab>
    </Tabs>
  </details>
</Callout>

<SquiggleEditor defaultCode="Sym.triangular(1, 2, 4)" />

## Mixture

```squiggle
mixture(...distributions: Distribution[], weights?: number[])
mixture(distributions: Distribution[], weights?: number[])
mx(...distributions: Distribution[], weights?: number[])
mx(distributions: Distribution[], weights?: number[])
```

The `mixture` mixes combines multiple distributions to create a mixture. You can optionally pass in a list of proportional weights.

<Tabs
  items={[
    "Simple",
    "With Weights",
    "With Continuous and Discrete Inputs",
    "Array of Distributions Input",
  ]}
>
  <Tab>
    <SquiggleEditor defaultCode="mixture(1 to 2, 5 to 8, 9 to 10)" />
  </Tab>
  <Tab>
    <SquiggleEditor defaultCode="mixture(1 to 2, 5 to 8, 9 to 10, [0.1, 0.1, 0.8])" />
  </Tab>
  <Tab>
    <SquiggleEditor defaultCode="mixture(1 to 5, 8 to 10, 1, 3, 20)" />
  </Tab>
  <Tab>
    <SquiggleEditor defaultCode="mx([1 to 2, exponential(1)], [1,1])" />
  </Tab>
</Tabs>

### Arguments

- `distributions`: A set of distributions or numbers, each passed as a paramater. Numbers will be converted into point mass distributions.
- `weights`: An optional array of numbers, each representing the weight of its corresponding distribution. The weights will be re-scaled to add to `1.0`. If a weights array is provided, it must be the same length as the distribution paramaters.

### Aliases

- `mx`

### Special Use Cases of Mixtures

<details>
  <summary>🕐 Zero or Continuous</summary>
  One common reason to have mixtures of continous and discrete distributions is to handle the special case of 0.
  Say I want to model the time I will spend on some upcoming project. I think I have an 80% chance of doing it.  

  In this case, I have a 20% chance of spending 0 time with it. I might estimate my hours with,
  <SquiggleEditor
    defaultCode={`hours_the_project_will_take = 5 to 20
chance_of_doing_anything = 0.8
mx(hours_the_project_will_take, 0, [chance_of_doing_anything, 1 - chance_of_doing_anything])`}
  />
</details>

<details>
  <summary>🔒 Model Uncertainty Safeguarding</summary>
  One technique several <a href="https://www.foretold.io/">Foretold.io</a> users used is to combine their main guess, with a
  "just-in-case distribution". This latter distribution would have very low weight, but would be
  very wide, just in case they were dramatically off for some weird reason.
<SquiggleEditor
  defaultCode={`forecast = 3 to 30
chance_completely_wrong = 0.05
forecast_if_completely_wrong = normal({p5:-100, p95:200})
mx(forecast, forecast_if_completely_wrong, [1-chance_completely_wrong, chance_completely_wrong])`}
/>

</details>
## SampleSet.fromList

```squiggle
SampleSet.fromList(samples:number[])
```

Creates a sample set distribution using an array of samples.  

Samples are converted into PDFs automatically using [kernel density estimation](https://en.wikipedia.org/wiki/Kernel_density_estimation) and an approximated bandwidth. This is an approximation and can be error-prone.

<SquiggleEditor defaultCode="SampleSet.fromList([1,2,3,4,6,5,5,5])" />

### Arguments

- `samples`: An array of at least 5 numbers.

## PointSet.makeContinuous

```squiggle
PointSet.makeContinuous(points:{x: number, y: number})
```

Creates a continuous point set distribution using a list of points.

<SquiggleEditor
  defaultCode={`PointSet.makeContinuous([
  { x: 0, y: 0.1 },
  { x: 1, y: 0.2 },
  { x: 2, y: 0.15 },
  { x: 3, y: 0.1 }
])`}
/>

<Callout type="warning">
  **Caution!**  
  Distributions made with ``makeContinuous`` are not automatically normalized. We suggest normalizing them manually using the ``normalize`` function.
</Callout>

### Arguments

- `points`: An array of at least 3 coordinates.

## PointSet.makeDiscrete

```squiggle
PointSet.makeDiscrete(points:{x: number, y: number})
```

Creates a discrete point set distribution using a list of points.

<SquiggleEditor
  defaultCode={`PointSet.makeDiscrete([
  { x: 0, y: 0.2 },
  { x: 1, y: 0.3 },
  { x: 2, y: 0.4 },
  { x: 3, y: 0.1 }
])`}
/>

### Arguments

- `points`: An array of at least 1 coordinate.



---
description: This page documents control flow. Squiggle has if/else statements, but not for loops.
---

import { SquiggleEditor } from "@quri/squiggle-components";

# Control Flow

This page documents control flow. Squiggle has if/else statements, but not for loops. But for for loops, you can use reduce/map constructs instead, which are also documented here.

## Conditionals

### If-else

```squiggle
if condition then result else alternative
```

<SquiggleEditor
  defaultCode={`
x = 10
if x == 1 then 1 else 2
`}
/>

### If-else as a ternary operator

```squiggle
test ? result : alternative;
```

<SquiggleEditor
  defaultCode={`
x = 10
x == 0 ? 1 : 2
`}
/>

### Tips and tricks

#### Use brackets and parenthesis to organize control flow

<SquiggleEditor
  defaultCode={`
x = 10
if x == 1 then {
  1
} else {
  2
}
`}
/>

or

<SquiggleEditor
  defaultCode={`
x = 10
y = 20
if x == 1 then {
  (
    if y == 0 then {
      1
    } else {
      2
    }
  )
} else {
  3
}
`}
/>

This is overkill for simple examples becomes useful when the control conditions are more complex.

#### Save the result to a variable

Assigning a value inside an if/else flow isn't possible:

```squiggle
x = 10
y = 20
if x == 1 then {
  y = 1
} else {
  y = 2 * x
}
```

Instead, you can do this:

<SquiggleEditor
  defaultCode={`
x = 10
y = 20
y = if x == 1 then {
  1
} else {
  2 * x
}
`}
/>

Likewise, for assigning more than one value, you can't do this:

```squiggle
y = 0
z = 0
if x == 1 then {
  y = 2
} else {
  z = 4
}
```

Instead, do:

<SquiggleEditor
  defaultCode={`
x = 10
result = if x == 1 then {
  {y: 2, z: 0}
} else {
  {y: 0, z: 4}
}
y = result.y
z = result.z
`}
/>

## For loops

For loops aren't supported in Squiggle. Instead, use a [map](/docs/Api/List#map) or a [reduce](/docs/Api/List#reduce) function.

Instead of:

```js
xs = [];
for (i = 0; i < 10; i++) {
  xs[i] = f(x);
}
```

do:

<SquiggleEditor
  defaultCode={`
f(x) = 2*x
xs = List.upTo(0,10)
ys = List.map(xs, {|x| f(x)})
`}
/>



---
description: Much of the Squiggle math is imprecise. This can cause significant errors, so watch out.
---

import { SquiggleEditor } from "@quri/squiggle-components";

# Known Bugs

Much of the Squiggle math is imprecise. This can cause significant errors, so watch out.

Below are a few specific examples to watch for. We'll work on improving these over time and adding much better warnings and error management.

You can see an updated list of known language bugs [here](https://github.com/quantified-uncertainty/squiggle/issues?q=is%3Aopen+is%3Aissue+label%3ABug+label%3ALanguage).

## Operations on very small or large numbers, silently round to 0 and 1

Squiggle is poor at dealing with very small or large numbers, given fundamental limitations of floating point precision.
See [this Github Issue](https://github.com/quantified-uncertainty/squiggle/issues/834).

## Mixtures of distributions with very different means

If you take the pointwise mixture of two distributions with very different means, then the value of that gets fairly warped.

In the following case, the mean of the mixture should be equal to the sum of the means of the parts. These are shown as the first two displayed variables. These variables diverge as the underlying distributions change.

<SquiggleEditor
  defaultCode={`dist1 = {value: normal(1,1), weight: 1}
dist2 = {value: normal(100000000000,1), weight: 1}
totalWeight = dist1.weight + dist2.weight
distMixture = mixture(dist1.value, dist2.value, [dist1.weight, dist2.weight])
mixtureMean = mean(distMixture)
separateMeansCombined = (mean(dist1.value) * (dist1.weight) +  mean(dist2.value) * (dist2.weight))/totalWeight
[mixtureMean, separateMeansCombined, distMixture]`}
/>

## Means of Sample Set Distributions

The means of sample set distributions can vary dramatically, especially as the numbers get high.

<SquiggleEditor
  defaultCode={`symbolicDist = 5 to 50333333
sampleSetDist = SampleSet.fromDist(symbolicDist)
[mean(symbolicDist), mean(sampleSetDist), symbolicDist, sampleSetDist]`}
/>



---
description: "Basic Types"
---

import { SquiggleEditor } from "@quri/squiggle-components";

# Basic Types

## Numbers

Squiggle numbers are built directly on [Javascript numbers](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number). They can be integers or floats, and support all the usual arithmetic operations.  
[Number API](/docs/Api/Number)

Numbers support a few scientific notation suffixes.

| Suffix | Multiplier |
| ------ | ---------- |
| n      | 10^-9      |
| m      | 10^-3      |
| %      | 10^-2      |
| k      | 10^3       |
| M      | 10^6       |
| B,G    | 10^9       |
| T      | 10^12      |
| P      | 10^15      |

There's no difference between floats and integers in Squiggle.

<SquiggleEditor defaultCode={`n = 4.32
kilo = 4.32k
micro = 4.32m
veryLarge = 1e50
verySmall = 1e-50
`} />

## Booleans

Booleans can be `true` or `false`.

<SquiggleEditor defaultCode={`t = true
f = false`} />

## Strings

Strings can be created with either single or double quotes.  
[String API](/docs/Api/String)

<SquiggleEditor defaultCode={`s = "Double-quoted"
s2 = 'Single-quoted'`} />

## Distributions

Distributions are first-class citizens. Use the syntax `a to b` to create a quick lognormal distribution, or write out the whole distribution name.

<SquiggleEditor
  defaultCode={`a = 30 to 50
b = normal(4, 2)
c = lognormal({ mean: 90, stdev: 7 })
d = mixture(a, b, c, [.3, .3, .4])
d`}
/>

See these pages for more information on distributions:
- [Distribution Creation](/docs/Guides/DistributionCreation)
- [Distribution Functions Guide](/docs/Guides/Functions)
- [Distribution API](/docs/Api/Dist)

There are [3 internal representation formats for distributions](docs/Discussions/Three-Formats-Of-Distributions): [Sample Set](/docs/API/DistSampleSet), [Point Set](/docs/API/DistPointSet), and Symbolic. By default, Squiggle will use sample set distributions, which allow for correlations between parameters. Point Set and Symbolic distributions will be more accurate and fast, but do not support correlations. If you prefer this tradeoff, you can manually use them by adding a `Sym.` before the distribution name, i.e. `Sym.normal(0, 1)`.

## Lists

Squiggle lists can contain items of any type, similar to lists in Python. You can access individual list elements with `[number]` notation, starting from `0`. 

Squiggle is an immutable language, so you cannot modify lists in-place. Instead, you can use functions such as `List.map` or `List.reduce` to create new lists.  
[List API](/docs/Api/List)

<SquiggleEditor
  defaultCode={`myList = [1, "hello", 3 to 5, ["foo", "bar"]]
first = myList[0] // 1
bar = myList[3][1] // "bar"`}
/>


## Dictionaries

Squiggle dictionaries work similarly to Python dictionaries or Javascript objects. Like lists, they can contain values of any type. Keys must be strings.  
[Dictionary API](/docs/Api/Dictionary)

<SquiggleEditor
  defaultCode={`d = {dist: triangular(0, 1, 2), weight: 0.25, innerDict: {foo: "bar"}}`}
/>


## Other types

Other Squiggle types include:

- [Functions](/docs/Guides/Functions)
- [Plots](/docs/Api/Plot)
- [Scales](/docs/Api/Plot#scales)
- [Domains](#parameter-annotations)


---
description: The table module helps you create tables of data.
---

import { SquiggleEditor } from "@quri/squiggle-components";

# Table

The Table module allows you to make tables of data.

### Table.make

```
Table.make: ({
  data: list<'a>,
  title?: string,
  columns: list<{
    name?:string,
    fn: 'a => any
  }>
}) => table
```

Examples:

<SquiggleEditor
  defaultCode={`Table.make({
    data: [
        { name: "First Dist", value: normal(0, 1) },
        { name: "Second Dist", value: uniform(2, 4) },
        { name: "Third Dist", value: uniform(5, 6) }
    ], 
    columns: [
        { name: "Name", fn: {|d| d.name} },
        { name: "Mean", fn: {|d| mean(d.value)} },
        { name: "Std Dev", fn: {|d| variance(d.value)} },
        { name: "Dist", fn: {|d| (d.value)} }
    ] 
})`}
/>

You can hardcode the scales to make the xAxis consistent between rows.

<SquiggleEditor
  defaultCode={`Table.make(
  {
    data: [
      { name: "First Dist", value: Sym.lognormal({ p5: 1, p95: 10 }) },
      { name: "Second Dist", value: Sym.lognormal({ p5: 5, p95: 30 }) },
      { name: "Third Dist", value: Sym.lognormal({ p5: 50, p95: 90 }) },
    ],
    columns: [
      { name: "Name", fn: {|d|d.name} },
      {
        name: "Plot",
        fn: {
          |d|
          Plot.dist(
          {
            dist: d.value,
            xScale: Scale.log({ min: 0.5, max: 100 }),
            showSummary: false,
          }
        )
        },
      },
    ],
  }
)
`}
/>



---
description: Functions for working with strings in Squiggle
---

# String

Strings support all JSON escape sequences, with addition of escaped single-quotes (for single-quoted strings)

```js
a = "'\" NUL:\u0000"
b = '\'" NUL:\u0000'
```

### make

Converts any type to a simple string. Note that information is typically lost in this process.

```
make: (any) => string
```

```squiggle
String.make(5 to 40)
String.make([3,4,5,2])
```
### concat

```
concat: (string, string) => string
```

```squiggle
s1 = concat("foo", "bar") // foobar
s2 = "foo" + "bar" // foobar
s3 = "foo" + 3 // foo3
```

### split 

```
split: (string, string) => list<string>
```

```squiggle
foo = "this_is_a_sentence"
bar = String.split(foo, "_")
```


---
description: The Plot module provides functions to create plots of distributions and functions.
---

import { SquiggleEditor } from "@quri/squiggle-components";

# Plot

The Plot module provides functions to create plots of distributions and functions.

Raw functions and distributions are plotted with default parameters, while plot objects created by functions from this module give you more control over chart parameters and access to more complex charts.

### Plot.dists

Plots one or more labeled distributions on the same plot. Distributions can be either continuous, discrete, or a single number.

```
Plot.dists: ({
  dists: list<{
    name: string,
    value: distribution | number
  }>,
  xScale: scale,
  yScale: scale,
  title: string,
  showSummary: bool
}) => plot
```

Examples:

<SquiggleEditor
  defaultCode={`Plot.dists({
    dists: [
        { name: "First Dist", value: normal(0, 1) },
        { name: "Second Dist", value: uniform(2, 4) },
    ], 
    xScale: Scale.symlog({ min: -2, max: 5})
})`}
/>

### Plot.dist

Like `Plot.dists`, but plots a single distribution.

```
Plot.dist: ({
  dist: dist,
  xScale: scale,
  yScale: scale,
  title: string,
  showSummary: bool
}) => plot
```

Examples:

<SquiggleEditor
  defaultCode={`Plot.dist({
    dist: normal(5,2),
    xScale: Scale.linear({ min: -2, max: 6, title: "X Axis Title"}),
    title: "A Simple Normal Distribution",
    showSummary: true
})`}
/>

### Plot.numericFn

Plots a function that outputs numeric values. This works by sampling the function at a fixed number of points. The number of points is adjustable with the `points` parameter.

```
Plot.numericFn: ({
  fn: (number => number),
  xScale: scale,
  yScale: scale,
  title: string,
  points: number
}) => plot
```

Examples:

<SquiggleEditor
  defaultCode={`Plot.numericFn({
  fn: {|t| t^2},
  xScale: Scale.log({
    min: 1,
    max: 100
  }),
  points: 10
})`}
/>

### Plot.distFn

```
Plot.distFn: ({
  fn: (number => dist),
  xScale: scale,
  yScale: scale,
  title: string,
  distXScale: scale,
  points: number
}) => plot
```

<SquiggleEditor
  defaultCode={`Plot.distFn({
  fn: {|t| normal(t,2)*normal(5,3)},
  title: "A Function of Value over Time",
  xScale: Scale.log({ min: 3, max: 100, title: "Time (years)"}),
  yScale: Scale.linear({ title: "Value"}),
  distXScale: Scale.linear({ tickFormat: '#x' }),
})`}
/>

### Plot.scatter

Plots a scatterplot. Requires two sample set distributions.

```
Plot.scatter: ({
  yDist: sampleSetDist,
  xDist: sampleSetDist,
  xScale: Scale,
  yScale: Scale,
  title: string,
}) => plot
```

<SquiggleEditor
  defaultCode={`xDist = SampleSet.fromDist(2 to 5)
yDist = normal({p5:-3, p95:3}) * 5 - xDist ^ 2
Plot.scatter({
  xDist: xDist,
  yDist: yDist,
  xScale: Scale.log({min: 1.5}),
})`}
/>

<SquiggleEditor
  defaultCode={`xDist = SampleSet.fromDist(normal({p5:-2, p95:5}))
yDist = normal({p5:-3, p95:3}) * 5 - xDist
Plot.scatter({
  title: "A Scatterplot",
  xDist: xDist,
  yDist: yDist,
  xScale: Scale.symlog({title: "X Axis Title"}),
  yScale: Scale.symlog({title: "Y Axis Title"}),
})`}
/>

### Scales

Chart axes can be scaled using the following functions. Each scale function accepts optional min and max value. Power scale accepts an extra exponent parameter.

We use D3 for the tick formats. You can read about custom tick formats [here](https://github.com/d3/d3-format).

```
Scale.log: ({
  min: number,
  max: number,
  tickFormat: string,
  title: string
}) => scale

Scale.linear: ({
  min: number,
  max: number,
  tickFormat: string,
  title: string
}) => scale

Scale.symlog: ({
  min: number,
  max: number,
  tickFormat: string,
  title: string,
  constant: number
}) => scale

Scale.power: ({
  min: number,
  max: number,
  tickFormat: string,
  title: string,
  exponent: number
}) => scale
```

**Scale.log**

**Scale.linear**

**Scale.symlog**  
Symmetric log scale. Useful for plotting data that includes zero or negative values.

The function accepts an additional `constant` parameter, used as follows: `Scale.symlog({constant: 0.1})`. This parameter allows you to allocate more pixel space to data with lower or higher absolute values. By adjusting this constant, you effectively control the scale's focus, shifting it between smaller and larger values. For more detailed information on this parameter, refer to the [D3 Documentation](https://d3js.org/d3-scale/symlog).

The default value for `constant` is `1`.

**Scale.power**  
Power scale. Accepts an extra `exponent` parameter, like, `Scale.power({exponent: 2, min: 0, max: 100})`.

The default value for `exponent` is `0.1`.



---
description: Squiggle numbers are Javascript floats.
---

# Number

Squiggle `numbers` are Javascript floats.

Many of the functions below work on lists or pairs of numbers.

### ceil

```
ceil: (number) => number
```

### floor

```
floor: (number) => number
```

### abs

```
abs: (number) => number
```

### round

```
round: (number) => number
```

## Statistics

### max

```
max: (list<number>) => number
max: (number, number) => number
```

### min

```
min: (list<number>) => number
min: (number, number) => number
```

### mean

```
mean: (list<number>) => number
```

### geometric mean

```
geomean: (list<number>) => number
```

### stdev

```
stdev: (list<number>) => number
```

### variance

```
variance: (list<number>) => number
```

## Algebra

### unaryMinus

```
unaryMinus: (number) => number
```

### equal

```
equal: (number, number) => boolean
```

### add

```
add: (number, number) => number
```

### sum

```
sum: (list<number>) => number
```

### cumulative sum

```
cumsum: (list<number>) => list<number>
```

### multiply

```
multiply: (number, number) => number
```

### product

```
product: (list<number>) => number
```

### cumulative product

```
cumprod: (list<number>) => list<number>
```

### diff

```
diff: (list<number>) => list<number>
```

### sort

```
sort: (list<number>) => list<number>
```

### subtract

```
subtract: (number, number) => number
```

### divide

```
divide: (number, number) => number
```

### pow

```
pow: (number, number) => number
```

### exp

```
exp: (number) => number
```

### log

```
log: (number) => number
```



---
description: Math functions and constants
---

# Math

### E

```
Math.e:
```

Euler's number; ≈ 2.718281828459045

### LN2

```
Math.ln2:
```

Natural logarithm of 2; ≈ 0.6931471805599453

### LN10

```
Math.ln10:
```

Natural logarithm of 10; ≈ 2.302585092994046

### LOG2E

```
Math.log2e:
```

Base 2 logarithm of E; ≈ 1.4426950408889634Base 2 logarithm of E; ≈ 1.4426950408889634

### LOG10E

```
Math.log10e:
```

Base 10 logarithm of E; ≈ 0.4342944819032518

### PI

```
Math.pi:
```

Pi - ratio of the circumference to the diameter of a circle; ≈ 3.141592653589793

### SQRT1_2

```
Math.sqrt1_2:
```

Square root of 1/2; ≈ 0.7071067811865476

### SQRT2

```
Math.sqrt2:
```

Square root of 2; ≈ 1.4142135623730951

### PHI

```
Math.phi:
```

Phi is the golden ratio. 1.618033988749895

### TAU

```
Math.tau:
```

Tau is the ratio constant of a circle's circumference to radius, equal to 2 \* pi. 6.283185307179586

### Math functions

```
Math.sqrt(x) // Square root
Math.sin(x) // Sine
Math.cos(x) // Cosine
Math.tan(x) // Tangent
Math.asin(x) // Arcsine (inverse sine)
Math.acos(x) // Arccosine (invers cosine)
Math.atan(x) // Acrtangent (inverse tangent)
```



---
description: Squiggle lists are a lot like Python lists or Ruby arrays. They accept all types.
---

# List

Squiggle lists are a lot like Python lists or Ruby arrays. They accept all types.

```squiggle
myList = [3, normal(5, 2), "random"]
```

## List Creation

### make

```
List.make: (number, 'a) => list<'a>
List.make: (number, () => 'a) => list<'a>
List.make: (number, (index: number) => 'a) => list<'a>
```

Returns an array of size `n` filled with the value.

```squiggle
List.make(4, 1) // [1, 1, 1, 1]
List.make(3, {|index| index * 2}) // [2,4,6]
```

See [Rescript implementation](https://rescript-lang.org/docs/manual/latest/api/belt/array#make)

### upTo

```
List.upTo: (low:number, high:number) => list<number>
```

```squiggle
List.upTo(0, 5) // [0, 1, 2, 3, 4, 5]
```

Syntax taken from [Ruby](https://apidock.com/ruby/v2_5_5/Integer/upto).


## List Querying and Reading 

### first

```
List.first: (list<'a>) => 'a
```

### last

```
List.last: (list<'a>) => 'a
```

### length

```
List.length: (list<'a>) => number
```

### find

Returns an error if there is no value found.
```
List.find: (list<'a>, ('a) => bool) => 'a
```

### findIndex

Returns `-1` if there is no value found.

```
List.findIndex: (list<'a>, 'a => bool) => number
```

### every

```
List.every: (list<'a>, 'a => bool) => list<'a>
```

### some

```
List.some: (list<'a>, 'a => bool) => list<'a>
```

## List Modification

Please note that methods in the standard library are immutable. They do not alter the input data; instead, they return a modified version.
### concat

```
List.concat: (list<'a>, list<'a>) => list<'a>
```

### append

```
List.append: (list<'a>, <'a>) => list<'a>
```

### reverse

```
List.reverse: (list<'a>) => list<'a>
```
### shuffle

```
List.shuffle: (list<'a>) => list<'a>
```

### zip

```
List.zip: (list<'a>, list<'b>) => list<['a,'b]>
```

### unzip

```
List.unzip: (list<['a,'b]>) => list<'a>, list<'b>
```

### join

```
List.join: (list<string>, string) => string
```

```squiggle
List.join(["foo", "bar", "char"], "--") // "foo--bar--char"
```

### flatten

```
flatten: (list<list>) => list
```

```squiggle
List.flatten([
  [1, 2],
  [3, 4],
]) // [1,2,3,4]
```

## List Sorting

### sortBy
```
List.sortBy: (list<'a>, ('a => number)) => list<'a>
```

```squiggle
List.sortBy(
[
  {a:2, b:10}
  {a:10, b:3}
],
{|obj| obj.b}
) // [{a:10, b:3}, {a:2, b:10}]
```

### minBy
```
List.minBy: (list<'a>, ('a => number)) => 'a
```

### maxBy
```
List.maxBy: (list<'a>, ('a => number)) => 'a
```

## List Filtering

### slice
```
List.slice: (list<'a>, minIndex: number) => list<'a>
List.slice: (list<'a>, minIndex: number, maxIndex: number) => list<'a>
```

Returns a copy of the list, between the selected ``start`` and ``end``, end not included. Directly uses the [Javascript implementation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) underneath.

```squiggle
List.slice([1,2,3,4,5,6], 2) // [3,4,5,6]
List.slice([1,2,3,4,5,6], 2, 4) // [3,4]
```


### filter

```
List.filter: (list<'a>, 'a => bool) => list<'a>
```

See [Rescript implementation of keep](https://rescript-lang.org/docs/manual/latest/api/belt/array#keep), which is functionally equivalent.

### uniq

Filters the list for unique elements. Now only works on some Squiggle types.

```
List.uniq: (list<'a>) => list<'a>
```

```squiggle
List.uniq(["foobar", "foobar", 1, 1, 2]) // ["foobar", 1, 2]
```

### uniqBy

Filters the list for unique elements. Now only works on some Squiggle types.

```
List.uniqBy: (list<'a>, 'a => 'b) => list<'a>
```

```squiggle
List.uniqBy([{a: 3, b: 10}, {a:3, b:40}, {a:5, b:20}], {|e| e.a}) // [{a: 3, b: 10}, {a:5, b:20}]
```

## Functional Transformations

### map

```
map: (list<'a>, 'a => 'b) => list<'b>
map: (list<'a>, ('a, index: number) => 'b) => list<'b>
```

```squiggle
map(["foo", "bar"], {|s| s + "!"})
map(["foo", "bar"], {|s, i| {word: s, index: i}})
```

See [Rescript implementation](https://rescript-lang.org/docs/manual/latest/api/belt/array#map).


### reduce

```
reduce: (list<'b>, 'a, ('a, 'b) => 'a) => 'a
reduce: (list<'b>, 'a, ('a, 'b, index: number) => 'a) => 'a
```

`reduce(arr, init, f)`

Applies `f` to each element of `arr`. The function `f` has two main paramaters, an accumulator and the next value from the array. It can also accept an optional third `index` parameter.

```squiggle
reduce([2, 3, 4], 1, {|acc, value| acc + value}) == 10
```

See [Rescript implementation](https://rescript-lang.org/docs/manual/latest/api/belt/array#reduce).

### reduce reverse

```
reduceReverse: (list<'b>, 'a, ('a, 'b) => 'a) => 'a
```

Works like `reduce`, but the function is applied to each item from the last back to the first.

See [Rescript implementation](https://rescript-lang.org/docs/manual/latest/api/belt/array#reducereverse).

### reduceWhile

```
List.reduceWhile: (list<'b>, 'a, ('a, 'b) => 'a, ('a) => bool) => 'a
```

Works like `reduce`, but stops when the accumulator doesn't satisfy the condition, and returns the last accumulator that satisfies the condition (or the initial value if even the initial value doesn't satisfy the condition).

This is useful for simulating processes that need to stop based on the process state.

Example:

```js
/** Adds first two elements, returns `11`. */
List.reduceWhile([5, 6, 7], 0, {|acc, curr| acc + curr}, {|acc| acc < 15})

/** Adds first two elements, returns `{ x: 11 }`. */
List.reduceWhile([5, 6, 7], { x: 0 }, {|acc, curr| { x: acc.x + curr }}, {|acc| acc.x < 15})
```



---
description: Sample set distributions are one of the three distribution formats. Internally, they are stored as a list of numbers.
---

# Sample Set Distribution

Sample set distributions are one of the three distribution formats. Internally, they are stored as a list of numbers. It's useful to distinguish point set distributions from arbitrary lists of numbers to make it clear which functions are applicable.

Monte Carlo calculations typically result in sample set distributions.

All regular distribution function work on sample set distributions. In addition, there are several functions that only work on sample set distributions.

### make

Calls the correct conversion constructor, based on the corresponding input type, to create a Sample Set distribution. 

```
SampleSet.make: (distribution|list<number>) => pointSetDist
SampleSet.make: (() => number) => pointSetDist
SampleSet.make: ((index: number) => number) => pointSetDist
```

### fromDist

```
SampleSet.fromDist: (distribution) => sampleSet
```

### fromNumber

```
SampleSet.fromNumber: (number) => sampleSet
```

### fromList

```
SampleSet.fromList: (list<number>) => sampleSet
```

### fromFn

```
SampleSet.fromFn: ((float) => number) => sampleSet
```

```
PointSet.fromNumber: (number) => sampleSet
```

### toList

```
SampleSet.toList: (sampleSet) => list<number>
```

Gets the internal samples of a sampleSet distribution. This is separate from the sampleN() function, which would shuffle the samples. toList() maintains order and length.

**Examples**

```
toList(SampleSet.fromDist(normal(5,2)))
```

### map

```
SampleSet.map: (sampleSet, (number => number)) => sampleSet
```

### map2

```
SampleSet.map2: (sampleSet, sampleSet, ((number, number) => number)) => sampleSet
```

### map3

```
SampleSet.map3: (sampleSet, sampleSet, sampleSet, ((number, number, number) => number)) => sampleSet
```

### mapN

```
SampleSet.mapN: (list<sampleSet>, (list<sampleSet> => number)) => sampleSet
```



---
description: Point set distributions are one of the three distribution formats. They are stored as a list of x-y coordinates representing both discrete and continuous distributions.
---

# Point Set Distribution

Point set distributions are one of the three distribution formats. They are stored as a list of x-y coordinates representing both discrete and continuous distributions.

One complication is that it's possible to represent invalid probability distributions in the point set format. For example, you can represent shapes with negative values, or shapes that are not normalized.

### make

Calls fromDist for distributions, and fromNumber for numbers.
```
PointSet.make: (distribution|number) => pointSetDist
```

### fromDist

Converts the distribution in question into a point set distribution. If the distribution is symbolic, then it does this by taking the quantiles. If the distribution is a sample set, then it uses a version of kernel density estimation to approximate the point set format. One complication of this latter process is that if there is a high proportion of overlapping samples (samples that are exactly the same as each other), it will convert these samples into discrete point masses. Eventually we'd like to add further methods to help adjust this process.

```
PointSet.fromDist: (distribution) => pointSetDist
```

### fromNumber

```
PointSet.fromNumber: (number) => pointSetDist
```

### makeContinuous

Converts a set of x-y coordinates directly into a continuous distribution.

```
PointSet.makeContinuous: (list<{x: number, y: number}>) => pointSetDist
```

```squiggle
PointSet.makeContinuous([
  { x: 0, y: 0.1 },
  { x: 1, y: 0.2 },
  { x: 2, y: 0.15 },
  { x: 3, y: 0.1 },
])
```

### makeDiscrete

```
PointSet.makeDiscrete: (list<{x: number, y: number}>) => pointSetDist
```

```squiggle
PointSet.makeDiscrete([
  { x: 0, y: 0.1 },
  { x: 1, y: 0.2 },
  { x: 2, y: 0.15 },
  { x: 3, y: 0.1 },
])
```

### mapY

```
PointSet.mapY: (pointSetDist, (number => number)) => pointSetDist
```

```squiggle
normal(5,3) -> PointSet.fromDist -> PointSet.mapY({|x| x ^ 2}) -> normalize
```



---
description: Distributions are the flagship data type in Squiggle. The distribution type is a generic data type that contains one of three different formats of distributions.
---

import { Callout } from "nextra/components";

# Distribution

Distributions are the flagship data type in Squiggle. The distribution type is a generic data type that contains one of three different formats of distributions.
These subtypes are [point set](/docs/Api/DistPointSet), [sample set](/docs/Api/DistSampleSet), and symbolic. The first two of these have a few custom functions that only work on them. You can read more about the differences between these formats [here](/docs/Discussions/Three-Formats-Of-Distributions).

Several functions below only can work on particular distribution formats.
For example, scoring and pointwise math requires the point set format. When this happens, the types are automatically converted to the correct format. These conversions are lossy.

Distributions are created as [sample sets](/Docs/Api/DistSampleSet) by default. To create a symbolic distribution, use `Sym.` namespace: `Sym.normal`, `Sym.beta` and so on.

## Distribution Creation

These are functions for creating primitive distributions. Many of these could optionally take in distributions as inputs. In these cases, Monte Carlo Sampling will be used to generate the greater distribution. This can be used for simple hierarchical models.

See a longer tutorial on creating distributions [here](/docs/Guides/DistributionCreation).

### normal

```
normal: (distribution|number, distribution|number) => distribution
normal: (dict<{p5: distribution|number, p95: distribution|number}>) => distribution
normal: (dict<{p10: distribution|number, p90: distribution|number}>) => distribution
normal: (dict<{p25: distribution|number, p75: distribution|number}>) => distribution
normal: (dict<{mean: distribution|number, stdev: distribution|number}>) => distribution
```

**Examples**

```squiggle
normal(5, 1)
normal({ p5: 4, p95: 10 })
normal({ p10: 5, p95: 9 })
normal({ p25: 5, p75: 9 })
normal({ mean: 5, stdev: 2 })
normal(5 to 10, normal(3, 2))
normal({ mean: uniform(5, 9), stdev: 3 })
```

### lognormal

```
lognormal: (distribution|number, distribution|number) => distribution
lognormal: (dict<{p5: distribution|number, p95: distribution|number}>) => distribution
lognormal: (dict<{p10: distribution|number, p90: distribution|number}>) => distribution
lognormal: (dict<{p25: distribution|number, p75: distribution|number}>) => distribution
lognormal: (dict<{mean: distribution|number, stdev: distribution|number}>) => distribution
```

**Examples**

```squiggle
lognormal(0.5, 0.8)
lognormal({ p5: 4, p95: 10 })
lognormal({ p10: 5, p95: 9 })
lognormal({ p25: 5, p75: 9 })
lognormal({ mean: 5, stdev: 2 })
```

### to

The `to` function is an easy way to generate simple distributions using predicted _5th_ and _95th_ percentiles.

`To` is simply an alias for `lognormal({p5:low, p95:high})`. It does not accept values of 0 or less, as those are not valid for lognormal distributions.

```
to: (distribution|number, distribution|number) => distribution
```

**Examples**

```squiggle
5 to 10
to(5,10)
```


### uniform

```
uniform: (distribution|number, distribution|number) => distribution
```

**Examples**

```squiggle
uniform(10, 12)
```

### beta

```
beta: (distribution|number, distribution|number) => distribution
beta: (dict<{mean: distribution|number, stdev: distribution|number}>) => distribution
```

**Examples**

```squiggle
beta(20, 25)
beta({ mean: 0.39, stdev: 0.1 })
```

### cauchy

```
cauchy: (distribution|number, distribution|number) => distribution
```

**Examples**

```squiggle
cauchy(5, 1)
```

### gamma

```
gamma: (distribution|number, distribution|number) => distribution
```

**Examples**

```squiggle
gamma(5, 1)
```

### logistic

```
logistic: (distribution|number, distribution|number) => distribution
```

**Examples**

```squiggle
gamma(5, 1)
```

### exponential

```
exponential: (distribution|number) => distribution
```

**Examples**

```squiggle
exponential(2)
```

### bernoulli

```
bernoulli: (distribution|number) => distribution
```

**Examples**

```squiggle
bernoulli(0.5)
```

### triangular

```
triangular: (number, number, number) => distribution;
```

**Examples**

```squiggle
triangular(5, 10, 20)
```

### mixture

```
mixture: (...distributionLike, weights?:list<float>) => distribution
mixture: (list<distributionLike>, weights?:list<float>) => distribution
```

Note: If you want to pass in over 5 distributions, you must use the list syntax.

**Examples**

```squiggle
mixture(normal(5, 1), normal(10, 1), 8)
mx(normal(5, 1), normal(10, 1), [0.3, 0.7])
mx([normal(5, 1), normal(10, 1)], [0.3, 0.7])
```

## Functions

### make 

Make a distribution, starting with either a number of a distribution.

```
make: (distribution|number) => distribution 
```


### sample

One random sample from the distribution

```
sample: (distribution) => number
```

**Examples**

```squiggle
sample(normal(5, 2))
```

### sampleN

N random samples from the distribution

```
sampleN: (distribution, number) => list<number>
```

**Examples**

```squiggle
sampleN(normal(5, 2), 100)
```

### mean

The distribution mean

```
mean: (distribution) => number
```

**Examples**

```squiggle
mean(normal(5, 2))
```

### stdev

Standard deviation. Only works now on sample set distributions (so converts other distributions into sample set in order to calculate.)

```
stdev: (distribution) => number
```

### variance

Variance. Similar to stdev, only works now on sample set distributions.

```
variance: (distribution) => number
```

### cdf

```
cdf: (distribution, number) => number
```

**Examples**

```squiggle
cdf(normal(5, 2), 3)
```

### pdf

```
pdf: (distribution, number) => number
```

**Examples**

```squiggle
pdf(normal(5, 2), 3)
```

### quantile

```
quantile: (distribution, number) => number
```

**Examples**

```squiggle
quantile(normal(5, 2), 0.5)
```

### truncate

Truncates both the left side and the right side of a distribution.

```
truncate: (distribution, left: number, right: number) => distribution
```

<Callout type="info">
  **Implementation Details**  
  Sample set distributions are truncated by filtering samples, but point set
  distributions are truncated using direct geometric manipulation. Uniform
  distributions are truncated symbolically. Symbolic but non-uniform
  distributions get converted to Point Set distributions.
</Callout>

### truncateLeft

Truncates the left side of a distribution.

```
truncateLeft: (distribution, left: number) => distribution
```

**Examples**

```squiggle
truncateLeft(normal(5, 2), 3)
```

### truncateRight

Truncates the right side of a distribution.

```
truncateRight: (distribution, right: number) => distribution
```

**Examples**

```squiggle
truncateRight(normal(5, 2), 6)
```

### klDivergence

[Kullback–Leibler divergence](https://en.wikipedia.org/wiki/Kullback%E2%80%93Leibler_divergence) between two distributions.

Note that this can be very brittle. If the second distribution has probability mass at areas where the first doesn't, then the result will be infinite. Due to numeric approximations, some probability mass in point set distributions is rounded to zero, leading to infinite results with klDivergence.

```
klDivergence: (distribution, distribution) => number
```

**Examples**

```squiggle
Dist.klDivergence(normal(5, 2), normal(5, 4)) // returns 0.57
```

### logScore

A log loss score. Often that often acts as a [scoring rule](https://en.wikipedia.org/wiki/Scoring_rule). Useful when evaluating the accuracy of a forecast.

Note that it is fairly slow.

```
Dist.logScore: ({estimate: distribution, ?prior: distribution, answer: distribution|number}) => number
```

**Examples**

```squiggle
Dist.logScore({
  estimate: normal(5, 2),
  answer: normal(4.5, 1.2),
  prior: normal(6, 4),
}) // returns -0.597.57
```

## Display

### toString

```
toString: (distribution) => string
```

**Examples**

```squiggle
toString(normal(5, 2))
```

### sparkline

Produce a sparkline of length n. For example, `▁▁▁▁▁▂▄▆▇██▇▆▄▂▁▁▁▁▁`. These can be useful for testing or quick text visualizations.

```
sparkline: (distribution, n = 20) => string
```

**Examples**

```squiggle
sparkline(truncateLeft(normal(5, 2), 3), 20) // produces ▁▇█████▇▅▄▃▂▂▁▁▁▁▁▁▁
```

## Normalization

There are some situations where computation will return unnormalized distributions. This means that their cumulative sums are not equal to 1.0. Unnormalized distributions are not valid for many relevant functions; for example, klDivergence and scoring.

The only functions that do not return normalized distributions are the pointwise arithmetic operations and the scalewise arithmetic operations. If you use these functions, it is recommended that you consider normalizing the resulting distributions.

### normalize

Normalize a distribution. This means scaling it appropriately so that it's cumulative sum is equal to 1. This only impacts Point Set distributions, because those are the only ones that can be non-normlized.

```
normalize: (distribution) => distribution
```

**Examples**

```squiggle
normalize(normal(5, 2))
```

### isNormalized

Check of a distribution is normalized. Most distributions are typically normalized, but there are some commands that could produce non-normalized distributions.

```
isNormalized: (distribution) => bool
```

**Examples**

```squiggle
isNormalized(normal(5, 2)) // returns true
```

### integralSum

**Note: If you have suggestions for better names for this, please let us know.**

Get the sum of the integral of a distribution. If the distribution is normalized, this will be 1.0. This is useful for understanding unnormalized distributions.

```
integralSum: (distribution) => number
```

**Examples**

```squiggle
integralSum(normal(5, 2))
```

## Regular Arithmetic Operations

Regular arithmetic operations cover the basic mathematical operations on distributions. They work much like their equivalent operations on numbers.

The infixes `+`,`-`, `*`, `/`, `^` are supported for addition, subtraction, multiplication, division, power, and unaryMinus.

```squiggle
pointMass(5 + 10) == pointMass(5) + pointMass(10);
```

### add

```
add: (distributionLike, distributionLike) => distribution
```

**Examples**

```squiggle
normal(0, 1) + normal(1, 3) // returns normal(1, 3.16...)
add(normal(0, 1), normal(1, 3)) // returns normal(1, 3.16...)
```

### sum

```
sum: (list<distributionLike>) => distribution
```

### cumulative sum

```
cumsum: (list<distributionLike>) => distribution
```

### multiply

```
multiply: (distributionLike, distributionLike) => distribution
```

### product

```
product: (list<distributionLike>) => distribution
```

### cumulative product

```
cumprod: (list<distributionLike>) => list<distribution>
```

### diff

```
diff: (list<distributionLike>) => list<distribution>
```


### subtract

```
subtract: (distributionLike, distributionLike) => distribution
```

### divide

```
divide: (distributionLike, distributionLike) => distribution
```

### pow

```
pow: (distributionLike, distributionLike) => distribution
```

### exp

```
exp: (distributionLike, distributionLike) => distribution
```

### log

```
log: (distributionLike, distributionLike) => distribution
```

### log10

```
log10: (distributionLike, distributionLike) => distribution
```

### unaryMinus

```
unaryMinus: (distribution) => distribution
```

**Examples**

```squiggle
-normal(5, 2) // same as normal(-5, 2)
unaryMinus(normal(5, 2)) // same as normal(-5, 2)
```

## Pointwise Arithmetic Operations

<Callout type="warning">
  **Unnormalized Results**  
  Pointwise arithmetic operations typically return unnormalized or completely
  invalid distributions. For example, the operation{" "}
  <code>normal(5,2) .- uniform(10,12)</code> results in a distribution-like
  object with negative probability mass.
</Callout>

Pointwise arithmetic operations cover the standard arithmetic operations, but work in a different way than the regular operations. These operate on the y-values of the distributions instead of the x-values. A pointwise addition would add the y-values of two distributions.

The infixes `.+`,`.-`, `.*`, `./`, `.^` are supported for their respective operations.

The `mixture` methods works with pointwise addition.

### dotAdd

```
dotAdd: (distributionLike, distributionLike) => distribution
```

### dotMultiply

```
dotMultiply: (distributionLike, distributionLike) => distribution
```

### dotSubtract

```
dotSubtract: (distributionLike, distributionLike) => distribution
```

### dotDivide

```
dotDivide: (distributionLike, distributionLike) => distribution
```

### dotPow

```
dotPow: (distributionLike, distributionLike) => distribution
```

### dotExp

```
dotExp: (distributionLike, distributionLike) => distribution
```



---
description: Squiggle dictionaries work similar to Python dictionaries. The syntax is similar to objects in Javascript.
---

# Dictionary

Squiggle dictionaries work similar to Python dictionaries. The syntax is similar to objects in Javascript.

Dictionaries are ordered. Duplicates are not allowed. They are immutable, like all types in Squiggle.

**Example**

```squiggle
table = 10 to 30
chair = 0.01 to 0.5

valueFromOfficeItems = {
  keyboard: 1,
  headphones: "ToDo",
  chair, table
}

valueFromHomeItems = {
  monitor: 1,
  bed: 0.2 to 0.6,
  lights: 0.02 to 0.2,
  coffee: 5 to 20,
  chair, table
}

homeToItemsConversion = 0.1 to 0.4

conversionFn(i) = [i[0], i[1] * homeToItemsConversion]
updatedValueFromHomeItems = valueFromHomeItems -> Dict.toList -> map(conversionFn) -> Dict.fromList

allItems = Dict.merge(valueFromOfficeItems, updatedValueFromHomeItems)
```

### toList

```
Dict.toList: (dict<'a>) => list<list<string|a>>
```

```squiggle
Dict.toList({ foo: 3, bar: 20 }) // [["foo", 3], ["bar", 20]]
```

### fromList

```
Dict.fromList: (list<list<string|'a>>) => dict<'a>
```

```squiggle
Dict.fromList([
  ["foo", 3],
  ["bar", 20],
]) // {foo: 3, bar: 20}
```

### keys

```
Dict.keys: (dict<'a>) => list<string>
```

```squiggle
Dict.keys({ foo: 3, bar: 20 }) // ["foo", "bar"]
```

### values

```
Dict.values: (dict<'a>) => list<'a>
```

```squiggle
Dict.values({ foo: 3, bar: 20 }) // [3, 20]
```

### merge

```
Dict.merge: (dict<'a>, dict<'b>) => dict<'a|b>
```

```squiggle
first = { a: 1, b: 2 };
snd = { b: 3, c: 5 };
Dict.merge(first, snd); // {a: 1, b: 3, c: 5}
```

### mergeMany

```
Dict.mergeMany: (list<dict<'a>>) => dict<'a>
```

```squiggle
first = { a: 1, b: 2 }
snd = { b: 3, c: 5 }
Dict.mergeMany([first, snd]) // {a: 1, b: 3, c: 5}
```

### set

```
Dict.set: (dict<'a>, string, 'a) => dict<'a>
```

Creates a new dictionary that includes the added element, while leaving the original dictionary unaltered.

### has

```
Dict.has: (dict<'a>, string) => boolean
```

### size

```
Dict.size: (dict<'a>) => number
```

### delete

```
Dict.delete: (dict<'a>, string) => dist<'a>
```

Creates a new dictionary, excluding the key-value pair associated with the specified key.

### map

```
Dict.map: (dict<'a>, (`a => `a)) => dict<'a>
```

```squiggle
Dict.map({a: 1, b: 2}, {|x| x + 1}) // { a: 2, b:3 }
```

### mapKeys

```
Dict.map: (dict<'a>, (string => string)) => dict<'a>
```

```squiggle
Dict.mapKeys({a: 1, b: 2}, {|x| x + "hi" }) // {ahi: 1, bhi: 2}
```

### pick

```
Dict.pick: (dict<'a>, list<string>) => dict<'a>
```

Selects only the keys from the dictionary that are specified in the list, and returns a new dictionary with those keys.

```squiggle
data = { a: 1, b: 2, c: 3, d: 4 }
Dict.pick(data, ["a", "c"]) // {a: 1, c: 3}
```

### omit

```
Dict.omit: (dict<'a>, list<string>) => dict<'a>
```

Removes the keys from the dictionary that are specified in the list, and returns a new dictionary without those keys.

```squiggle
data = { a: 1, b: 2, c: 3, d: 4 }
Dict.omit(data, ["b", "d"]) // {a: 1, c: 3}
```


---
description: The Danger library contains newer experimental functions which are less stable than Squiggle as a whole
---

# Danger

The Danger library contains newer experimental functions which are less stable than Squiggle as a whole. Beware: their name, behavior, namespace or existence may change at any time.

### laplace

```
Danger.laplace: (number, number) => number
```

Calculates the probability implied by [Laplace's rule of succession](https://en.wikipedia.org/wiki/Rule_of_succession)

```squiggle
trials = 10
successes = 1
Danger.laplace(trials, successes); //  (successes + 1) / (trials + 2)  = 2 / 12 = 0.1666
```

### factorial

```
Danger.factorial: (number) => number
```

Returns the factorial of a number

### choose

```
Danger.choose: (number, number) => number
```

`Danger.choose(n,k)` returns `factorial(n) / (factorial(n - k) *.factorial(k))`, i.e., the number of ways you can choose k items from n choices, without repetition. This function is also known as the [binomial coefficient](https://en.wikipedia.org/wiki/Binomial_coefficient).

### binomial

```
Danger.binomial: (number, number, number) => number
```

`Danger.binomial(n, k, p)` returns `choose((n, k)) * pow(p, k) * pow(1 - p, n - k)`, i.e., the probability that an event of probability p will happen exactly k times in n draws.


### binomialDist

```
Danger.binomialDist: (n: distribution|number,p: distribution|number) => distribution
```
A binomial distribution.

``n`` must be above 0, and ``p`` must be between 0 and 1. 

Note: The binomial distribution is a discrete distribution. When representing this, the Squiggle distribution component might show it as partially or fully continuous. This is a visual mistake; if you inspect the underlying data, it should be discrete.

**Examples**

```squiggle
binomialDist(5, 0.5)
binomialDist(10, 0.3)
```

### poissonDist 

```
Danger.poissonDist: (distribution|number) => distribution
```

Note: The Poisson distribution is a discrete distribution. When representing this, the Squiggle distribution component might show it as partially or fully continuous.  This is a visual mistake; if you inspect the underlying data, it should be discrete.

**Examples**

```squiggle
poissonDist(20)
```

### integrateFunctionBetweenWithNumIntegrationPoints

```
Danger.integrateFunctionBetweenWithNumIntegrationPoints: (number => number, number, number, number) => number
```

`Danger.integrateFunctionBetweenWithNumIntegrationPoints(f, min, max, numIntegrationPoints)` integrates the function `f` between `min` and `max`, and computes `numIntegrationPoints` in between to do so.

Note that the function `f` has to take in and return numbers. To integrate a function which returns distributios, use:

```squiggle
auxiliaryF(x) = mean(f(x))

Danger.integrateFunctionBetweenWithNumIntegrationPoints(auxiliaryF, min, max, numIntegrationPoints)
```

### integrateFunctionBetweenWithEpsilon

```
Danger.integrateFunctionBetweenWithEpsilon: (number => number, number, number, number) => number
```

`Danger.integrateFunctionBetweenWithEpsilon(f, min, max, epsilon)` integrates the function `f` between `min` and `max`, and uses an interval of `epsilon` between integration points when doing so. This makes its runtime less predictable than `integrateFunctionBetweenWithNumIntegrationPoints`, because runtime will not only depend on `epsilon`, but also on `min` and `max`.

Same caveats as `integrateFunctionBetweenWithNumIntegrationPoints` apply.

### optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions

```
Danger.optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions: (array<number => number>, number, number) => number
```

`Danger.optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions([f1, f2], funds, approximateIncrement)` computes the optimal allocation of $`funds` between `f1` and `f2`. For the answer given to be correct, `f1` and `f2` will have to be decreasing, i.e., if `x > y`, then `f_i(x) < f_i(y)`.

Example:

```squiggle
Danger.optimalAllocationGivenDiminishingMarginalReturnsForManyFunctions(
  [
    {|x| 20-x},
    {|y| 10}
  ],
  100,
  0.01
)
```

Note also that the array ought to have more than one function in it.

### combinations
```
Danger.combinations: (list<any>, number) => list<list<any>>
```
Returns all combinations of the input list taken r elements at a time. 

```squiggle
Danger.combinations([1, 2, 3], 2)) // [[1, 2], [1, 3], [2, 3]]
```

### allCombinations
```
Danger.allCombinations: (list<any>) => list<list<any>>
```
Returns all possible combinations of the elements in the input list.

```squiggle
Danger.allCombinations([1, 2, 3])) // [[1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]
```


---
description: The Calculator module helps you create custom calculators
---

import { SquiggleEditor } from "@quri/squiggle-components";

# Calculator

The Calculator module allows you to make custom calculators for functions. This is a form that's tied to a specific Squiggle function, where the inputs to the form are passed to that function, and the output of the function gets shown on the bottom.

Calculators can be useful for debugging functions or to present functions to end users.

### Calculator.make

```
Calculator.make: ({
  fn: ...arguments => any,
  title?: string,
  description?: string,
  fields: list<input>,
  autorun?: boolean = true,
  sampleCount?: number,
}) => calculator
```

``Calculator.make`` takes in a function, a description, and a list of fields. The function should take in the same number of arguments as the number of fields, and the arguments should be of the same type as the default value of the field.

Calculators require a list of Inputs to be passed in. Inputs are created using the ``Input`` module. The ``Input`` module has a few different functions for creating different types of inputs.

For calculators that take a long time to run, we recommend setting ``autorun`` to false. This will produce a button that the user can click to run the calculator.

Example:

<SquiggleEditor
  defaultCode={`Calculator.make(
  {
    fn: {|a, b,c,d| [a,b,c,d]},
    title: "Concat()",
    description: "This function takes in 4 arguments, then displays them",
    autorun: true,
    sampleCount: 10000,
    inputs: [
      Input.text({
        name: "First Param",
        default: "10 to 13",
        description: "Must be a number or distribution",
      }),
      Input.textArea({ name: "Second Param", default: "[4,5,2,3,4,5,3,3,2,2,2,3,3,4,45,5,5,2,1]" }),
      Input.select({ name: "Third Param", default: "Option 1", options: ["Option 1", "Option 2", "Option 3"] }),
      Input.checkbox({ name: "Fourth Param", default: false})
    ]
  }
)`}
/>

## Inputs

Inputs are now only used for creating calculators, as shown above. They are created using the ``Input`` module.

```
Input.text: ({
  name: string,
  description?: string,
  default?: string,
}) => input

Input.textArea: ({
  name: string,
  description?: string,
  default?: string,
}) => input

Input.checkbox: ({
  name: string,
  description?: string,
  default?: boolean,
}) => input

Input.select: ({
  name: string,
  description?: string,
  default?: string,
  options: string[]
}) => input
```


---
description: Builtin functions that work on many types.
---

### typeOf 

Returns the type of the value passed in as a string.
```
typeOf: (any) => string
```

### inspect 

Runs Console.log() in the Javascript console and returns the value passed in.
```
inspect: (`a) => `a
```