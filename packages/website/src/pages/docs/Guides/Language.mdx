---
description: "Language essentials: an overview of syntax, types, operators, functions, and more"
---

import { SquiggleEditor } from "@quri/squiggle-components";

# Language Basics

Squiggle supports some simple types and language features.

## Basic types

### Numbers

There's no difference between floats and integers in Squiggle.

Numbers support a few scientific notation suffixes.

| suffix | multiplier |
| ------ | ---------- |
| n      | 10^-9      |
| m      | 10^-3      |
| k      | 10^3       |
| M      | 10^6       |
| B,G    | 10^9       |
| T      | 10^12      |
| P      | 10^15      |

<SquiggleEditor defaultCode={`n = 4.32
kilo = 4.32k
micro = 4.32m`} />

### Booleans

Can be `true` or `false`.

<SquiggleEditor defaultCode={`t = true
f = false`} />

### Strings

<SquiggleEditor defaultCode={`s = "Double-quoted"
s2 = 'Single-quoted'`} />

### Distributions

Distributions are first-class citizens in Squiggle. There are several ways to create them:

- [to](/docs/Guides/DistributionCreation#to) operator.
- [constructors for many kinds of distributions](/docs/Api/Dist#distribution-creation): `normal`, `lognormal`, `uniform`, and so on.
- distributions can be combined with [mixture](/docs/Api/Dist#mixture) function or with [arithmetic operations](/Api/Dist#regular-arithmetic-operations).

 See the [Dist module documentation](/docs/Api/Dist) for a complete API.

<SquiggleEditor
  defaultCode={`a = 30 to 50
b = normal(4, 2)
c = lognormal({ mean: 90, stdev: 7 })
d = mixture(a, b, c, [.3, .3, .4])
d`}
/>

## Container types

### Lists

Squiggle lists can contain items of any type, similar to those in Python.

You can access individual list elements with `[number]` notation, starting from `0`.

For common operations on lists, refer to the [List module API](/docs/Api/List).

<SquiggleEditor
  defaultCode={`myList = [1, "hello", 3 to 5, ["foo", "bar"]]
first = myList[0] // 1
bar = myList[3][1] // "bar"`}
/>

### Dictionaries

Squiggle dictionaries work similarly to Python dictionaries or Javascript objects.

For common operations on dictionaries, refer to the [Dict module API](/docs/Api/Dictionary).

<SquiggleEditor
  defaultCode={`d = {dist: triangular(0, 1, 2), weight: 0.25}
d.dist`}
/>

## Other types

Other value types that Squiggle has include:
- [Functions](#functions)
- [Plot objects](/docs/Api/Plot)
- [Scales](/docs/Api/Plot#scales)
- [Domains](#parameter-annotations)

## Program structure

A Squiggle program consists of a series of definitions (for example, `x = 5`, `f(x) = x * x`). This can optionally conclude with an "end expression".

If an end expression is provided, it becomes the evaluated output of the program, and only this result will be displayed in the viewer.

Otherwise, all top-level variable definitions will be displayed.

<SquiggleEditor
  defaultCode={`x = 5
y = 10
x + y`}
/>

<SquiggleEditor
  defaultCode={`x = 5
y = 10`}
/>

## Immutability

All variables in Squiggle are immutable, similar to other functional programming languages like OCaml or Haskell.

In the case of container types (lists and dictionaries), this implies that an operation such as myList[3] = 10 is not permitted. Instead, we recommend using `List.map`, `List.reduce` or other [List functions](/docs/Api/List).

In case of basic types such as numbers or strings, the impact of immutability is more subtle.

Consider this code:

```squiggle
x = 5
x = x + 5
```

While it appears that the value of x has changed, what actually occurred is the creation of a new variable with the same name, which [shadowed](https://en.wikipedia.org/wiki/Variable_shadowing) the previous x variable.

In most shadowing scenarios, the result would be identical to what you'd expect in languages such as Javascript or Python.

One case where shadowing matters is closures:

<SquiggleEditor
  defaultCode={`x = 5
argPlusX(y) = x + y

x = x + 5

argPlusX(5)`}
/>

In the above example, the `argPlusX` function captures the value of `x` from line 1, not the newly shadowed `x` from line 4. As a result, `argPlusX(5)` returns 10, not 15.

## Blocks

Blocks are special expressions in Squiggle that can contain any number of local definitions and end with an expression.

<SquiggleEditor
defaultCode={`x = { 5 } // same as "x = 5"
y = {
  t = 10 // local variable, won't be available outside of the block body
  5 * t // end expression
}
`} />

## Functions

### Basic syntax

<SquiggleEditor
  defaultCode={`f(t) = normal(t^2, t^1.2+.01)
f`}
/>

There's no `return` statement in Squiggle; function definitions are values.

If you need to define local variables in functions, you can use blocks:

<SquiggleEditor
  defaultCode={`mul6(x) = {
  t = x * 2
  t * 3
}`}
/>

### Anonymous Functions

`f(x, y) = x * y` and `f = {|x, y| x * y}` are equivalent.

Squiggle functions are values, and you can save them to variables, pass them to other functions as arguments, return functions from functions, and so on.

<SquiggleEditor defaultCode={`{|t| normal(t^2, t^1.2+.01)}`} />

### Viewing functions

Squiggle viewer supports two types of functions:

1. `(number) => number`
2. `(number) => distribution`

<SquiggleEditor defaultCode={`numberToNumber(x) = x * x
numberToDist(x) = normal(x + 1, 3)
otherFunction(x, y) = x + y`} />

When Squiggle displays a single parameter function, it needs to select some range of parameter values.

The default range is `0...10`.

The default parameter value range can be overridden in several ways:

- With `Plot.numericFn` or `Plot.distFn` plots (look for `xScale` parameter)
- Through the chart's settings in the UI (look for a gear icon next to the variable name)
- By utilizing annotations (explained below)

### Parameter Annotations

Function parameters can be annotated with _domains_.

Examples:

- `x: Number.rangeDomain({ min: 5, max: 10 })`
- `x: [5, 10]` â€” shortcut for `Number.rangeDomain(...)`

Annotations help to document possible values that can be passed as a parameter's value.

Annotations will affect the parameter range used in the function's chart. For more control over function charts, you can use the [Plot module API](/docs/Api/Plot).

Domains are checked on function calls; `f(x: [1,2]) = x; f(3)` will fail.

We plan to support other kinds of domains in the future; for now, only numeric ranges are supported.

<SquiggleEditor
  defaultCode={`yearToValue(year: [2020, 2100]) = 1.04 ^ (year - 2020)`}
/>

### Reflection

<SquiggleEditor
  defaultCode={`f(x: [1, 20]) = x * x
f.parameters[0]`}
/>

Domains and parameter names can be accessed by `fn.parameters` property. 

For example, domains extracted with `.parameters` can be reused in annotations of other parameters:

<SquiggleEditor
  defaultCode={`f(x: [1, 20]) = x * x
g(x: f.parameters[0].domain) = x * x * x
`}
/>

## Conditionals

If/then/else statements in Squiggle are values too.

<SquiggleEditor
  defaultCode={`x = 5
if x<8 then 10 else 3`}
/>

See [Control flow](/docs/Guides/ControlFlow) for more details and examples.

## Comments

<SquiggleEditor
  defaultCode={`// This is a single-line comment\n
/*
This is a multiple
-line comment.
*/
foo = 5

/**
This is a docstring.
Because it starts with "/**", it will be displayed in the viewer if it precedes a public variable definition.
*/
bar = 6
`}
/>

## Pipes

Squiggle features [data-first](https://www.javierchavarri.com/data-first-and-data-last-a-comparison/) pipes. Functions in the standard library are organized to make this convenient.

<SquiggleEditor
  defaultCode={`normal(5,2) -> truncateLeft(3) -> SampleSet.fromDist -> SampleSet.map({|r| r + 10})`}
/>

## Standard Library

Squiggle features a simple [standard libary](/docs/Api/Dist).

Most functions are namespaced under their respective types to keep functionality distinct. Certain popular functions are usable without their namespaces.

For example,

<SquiggleEditor
  defaultCode={`a = List.upTo(0, 5000) -> SampleSet.fromList // namespaces required
b = normal(5,2) // namespace not required
c = 5 to 10 // namespace not required`}
/>
